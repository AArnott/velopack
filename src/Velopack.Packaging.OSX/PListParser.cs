#pragma warning disable CS1574 // XML comment has cref attribute that could not be resolved
#pragma warning disable CS1573 // Parameter has no matching param tag in the XML comment (but other parameters do)
#pragma warning disable CS0162 // Unreachable code detected

// File generated by dotnet-combine at 2022-05-07__11_02_05

// plist-cil - An open source library to parse and generate property lists for .NET
// Copyright (C) 2015 Natalia Portillo
//
// This code is based on:
// plist - An open source library to parse and generate property lists
// Copyright (C) 2014 Daniel Dreibrodt
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// plist-cil - An open source library to parse and generate property lists for .NET
// Copyright (C) 2015 Natalia Portillo
//
// This code is based on:
// plist - An open source library to parse and generate property lists
// Copyright (C) 2014 Daniel Dreibrodt
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// plist-cil - An open source library to parse and generate property lists for .NET
// Copyright (C) 2015 Natalia Portillo
// Copyright (C) 2016 Quamotion
//
// This code is based on:
// plist - An open source library to parse and generate property lists
// Copyright (C) 2014 Daniel Dreibrodt
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// plist-cil - An open source library to parse and generate property lists for .NET
// Copyright (C) 2016 Quamotion
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

using System;
using System.Buffers.Binary;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Numerics;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using System.Xml;

// ASCIIPropertyListParser.cs
namespace Squirrel.Packaging.OSX
{
    /// <summary>
    ///     <para>
    ///         Parser for ASCII property lists. Supports Apple OS X/iOS and GnuStep/NeXTSTEP format. This parser is based on
    ///         the recursive descent paradigm, but the underlying grammar is not explicitly defined.
    ///     </para>
    ///     <para>Resources on ASCII property list format:</para>
    ///     <para>https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/PropertyLists/OldStylePlists/OldStylePLists.html</para>
    ///     <para>Property List Programming Guide - Old-Style ASCII Property Lists</para>
    ///     <para>http://www.gnustep.org/resources/documentation/Developer/Base/Reference/NSPropertyList.html</para>
    ///     <para>GnuStep - NSPropertyListSerialization class documentation</para>
    /// </summary>
    /// @author Daniel Dreibrodt
    /// @author Natalia Portillo
    internal class ASCIIPropertyListParser
    {
        /// <summary>A space</summary>
        public const char WHITESPACE_SPACE = ' ';
        /// <summary>A tabulator</summary>
        public const char WHITESPACE_TAB = '\t';
        /// <summary>A newline</summary>
        public const char WHITESPACE_NEWLINE = '\n';
        /// <summary>A carriage return</summary>
        public const char WHITESPACE_CARRIAGE_RETURN = '\r';

        /// <summary>Token of NSArray start</summary>
        public const char ARRAY_BEGIN_TOKEN = '(';
        /// <summary>Token of NSArray end</summary>
        public const char ARRAY_END_TOKEN = ')';
        /// <summary>Token of NSArray item delimiter</summary>
        public const char ARRAY_ITEM_DELIMITER_TOKEN = ',';

        /// <summary>Token of NSDictionary start</summary>
        public const char DICTIONARY_BEGIN_TOKEN = '{';
        /// <summary>Token of NSDictionary end</summary>
        public const char DICTIONARY_END_TOKEN = '}';
        /// <summary>Token of NSDictionary assignment</summary>
        public const char DICTIONARY_ASSIGN_TOKEN = '=';
        /// <summary>Token of NSDictionary item delimiter</summary>
        public const char DICTIONARY_ITEM_DELIMITER_TOKEN = ';';

        /// <summary>Token of quoted NSString start</summary>
        public const char QUOTEDSTRING_BEGIN_TOKEN = '"';
        /// <summary>Token of quoted NSString end</summary>
        public const char QUOTEDSTRING_END_TOKEN = '"';
        /// <summary>Token of quoted NSString escaped character</summary>
        public const char QUOTEDSTRING_ESCAPE_TOKEN = '\\';

        /// <summary>Token of NSData start</summary>
        public const char DATA_BEGIN_TOKEN = '<';
        /// <summary>Token of NSData end</summary>
        public const char DATA_END_TOKEN = '>';

        /// <summary>Token of GSObject start</summary>
        public const char DATA_GSOBJECT_BEGIN_TOKEN = '*';
        /// <summary>Token of GSDate start</summary>
        public const char DATA_GSDATE_BEGIN_TOKEN = 'D';
        /// <summary>Token of GSBoolean start</summary>
        public const char DATA_GSBOOL_BEGIN_TOKEN = 'B';
        /// <summary>Token for GSBoolen's <c>true</c></summary>
        public const char DATA_GSBOOL_TRUE_TOKEN = 'Y';
        /// <summary>Token for GSBoolen's <c>false</c></summary>
        public const char DATA_GSBOOL_FALSE_TOKEN = 'N';
        /// <summary>Token for GSInteger</summary>
        public const char DATA_GSINT_BEGIN_TOKEN = 'I';
        /// <summary>Token for GSReal</summary>
        public const char DATA_GSREAL_BEGIN_TOKEN = 'R';

        /// <summary>Token for NSDate date field delimited</summary>
        public const char DATE_DATE_FIELD_DELIMITER = '-';
        /// <summary>Token for NSDate time field delimiter</summary>
        public const char DATE_TIME_FIELD_DELIMITER = ':';
        /// <summary>Token for GSDate date and time delimiter</summary>
        public const char DATE_GS_DATE_TIME_DELIMITER = ' ';
        /// <summary>Token for NSDate date and time delimiter</summary>
        public const char DATE_APPLE_DATE_TIME_DELIMITER = 'T';
        /// <summary>Token for NSDate end</summary>
        public const char DATE_APPLE_END_TOKEN = 'Z';

        /// <summary>Token for comment start</summary>
        public const char COMMENT_BEGIN_TOKEN = '/';
        /// <summary>Second token for multiline comment</summary>
        public const char MULTILINE_COMMENT_SECOND_TOKEN = '*';
        /// <summary>Second token for singleline comment</summary>
        public const char SINGLELINE_COMMENT_SECOND_TOKEN = '/';
        /// <summary>End token for multiline comment</summary>
        public const char MULTILINE_COMMENT_END_TOKEN = '/';

        /**
        * Property list source data
        */
        readonly char[] data;
        /**
        * Current parsing index
        */
        int index;

        /**
        * Only allow subclasses to change instantiation.
        */
        protected ASCIIPropertyListParser() {}

        /// <summary>Creates a new parser for the given property list content.</summary>
        /// <param name="propertyListContent">The content of the property list that is to be parsed.</param>
        ASCIIPropertyListParser(char[] propertyListContent) => data = propertyListContent;

        /// <summary>Parses an ASCII property list file.</summary>
        /// <param name="f">The ASCII property list file..</param>
        /// <returns>The root object of the property list. This is usually a NSDictionary but can also be a NSArray.</returns>
        /// <exception cref="FormatException">When an error occurs during parsing.</exception>
        /// <exception cref="IOException">When an error occured while reading from the input stream.</exception>
        public static NSObject Parse(FileInfo f) => Parse(f.OpenRead());

        /// <summary>Parses an ASCII property list from an input stream.</summary>
        /// <param name="fs">The input stream that points to the property list's data.</param>
        /// <returns>The root object of the property list. This is usually a NSDictionary but can also be a NSArray.</returns>
        /// <exception cref="FormatException">When an error occurs during parsing.</exception>
        /// <exception cref="IOException"></exception>
        public static NSObject Parse(Stream fs)
        {
            byte[] buf = PropertyListParser.ReadAll(fs);

            // Don't close the stream - that would be the responsibility of code that class
            // Parse
            return Parse(buf);
        }

        /// <summary>Parses an ASCII property list from a byte array.</summary>
        /// <param name="bytes">The ASCII property list data.</param>
        /// <returns>The root object of the property list. This is usually a NSDictionary but can also be a NSArray.</returns>
        /// <exception cref="FormatException">When an error occurs during parsing.</exception>
        public static NSObject Parse(byte[] bytes) => Parse(bytes.AsSpan());

        /// <summary>Parses an ASCII property list from a byte array.</summary>
        /// <param name="bytes">The ASCII property list data.</param>
        /// <param name="count">The offset at which to start reading the property list.</param>
        /// <param name="offset">The length of the property list.</param>
        /// <returns>The root object of the property list. This is usually a NSDictionary but can also be a NSArray.</returns>
        /// <exception cref="FormatException">When an error occurs during parsing.</exception>
        public static NSObject Parse(byte[] bytes, int offset, int count) => Parse(bytes.AsSpan(offset, count));

        /// <summary>Parses an ASCII property list from a byte span.</summary>
        /// <param name="bytes">The ASCII property list data.</param>
        /// <returns>The root object of the property list. This is usually a NSDictionary but can also be a NSArray.</returns>
        /// <exception cref="FormatException">When an error occurs during parsing.</exception>
        public static NSObject Parse(ReadOnlySpan<byte> bytes)
        {
        #if NATIVE_SPAN
            return ParseString(Encoding.UTF8.GetString(bytes));
        #else
            return ParseString(Encoding.UTF8.GetString(bytes.ToArray()));
        #endif
        }

        /// <summary>Parses an ASCII property list from a string.</summary>
        /// <param name="value">The ASCII property list data.</param>
        /// <returns>The root object of the property list. This is usually a NSDictionary but can also be a NSArray.</returns>
        /// <exception cref="FormatException">When an error occurs during parsing.</exception>
        public static NSObject ParseString(string value)
        {
            var parser = new ASCIIPropertyListParser(value.ToCharArray());

            return parser.Parse();
        }

        /// <summary>Checks whether the given sequence of symbols can be accepted.</summary>
        /// <returns>Whether the given tokens occur at the current parsing position.</returns>
        /// <param name="sequence">The sequence of tokens to look for.</param>
        bool AcceptSequence(params char[] sequence)
        {
            for(int i = 0; i < sequence.Length; i++)
                if(data[index + i] != sequence[i])
                    return false;

            return true;
        }

        /// <summary>
        ///     Checks whether the given symbols can be accepted, that is, if one of the given symbols is found at the current
        ///     parsing position.
        /// </summary>
        /// <param name="acceptableSymbols">The symbols to check.</param>
        /// <returns>Whether one of the symbols can be accepted or not.</returns>
        bool Accept(params char[] acceptableSymbols)
        {
            bool symbolPresent = false;

            foreach(char c in acceptableSymbols)
                symbolPresent |= data[index] == c;

            return symbolPresent;
        }

        /// <summary>
        ///     Checks whether the given symbol can be accepted, that is, if the given symbols is found at the current parsing
        ///     position.
        /// </summary>
        /// <param name="acceptableSymbol">The symbol to check.</param>
        /// <returns>Whether the symbol can be accepted or not.</returns>
        bool Accept(char acceptableSymbol) => data[index] == acceptableSymbol;

        /// <summary>Expects the input to have one of the given symbols at the current parsing position.</summary>
        /// <param name="expectedSymbols">The expected symbols.</param>
        /// <exception cref="FormatException">If none of the expected symbols could be found.</exception>
        void Expect(params char[] expectedSymbols)
        {
            if(Accept(expectedSymbols))
                return;

            string excString = "Expected '" + expectedSymbols[0] + "'";

            for(int i = 1; i < expectedSymbols.Length; i++)
                excString += " or '" + expectedSymbols[i] + "'";

            excString += " but found '" + data[index] + "'";

            throw new FormatException($"{excString} at {index}");
        }

        /// <summary>Expects the input to have the given symbol at the current parsing position.</summary>
        /// <param name="expectedSymbol">The expected symbol.</param>
        /// <exception cref="FormatException">If the expected symbol could be found.</exception>
        void Expect(char expectedSymbol)
        {
            if(!Accept(expectedSymbol))
                throw new FormatException($"Expected '{expectedSymbol}' but found '{data[index]}' at {index}");
        }

        /// <summary>Reads an expected symbol.</summary>
        /// <param name="symbol">The symbol to read.</param>
        /// <exception cref="FormatException">If the expected symbol could not be read.</exception>
        void Read(char symbol)
        {
            Expect(symbol);
            index++;
        }

        /**
     * Skips the current symbol.
     */
        void Skip() => index++;

        /// <summary>Skips several symbols</summary>
        /// <param name="numSymbols">The amount of symbols to skip.</param>
        void Skip(int numSymbols) => index += numSymbols;

        /**
     * Skips all whitespaces and comments from the current parsing position onward.
     */
        void SkipWhitespacesAndComments()
        {
            bool commentSkipped;

            do
            {
                commentSkipped = false;

                //Skip whitespaces
                while(Accept(WHITESPACE_CARRIAGE_RETURN, WHITESPACE_NEWLINE, WHITESPACE_SPACE, WHITESPACE_TAB))
                    Skip();

                //Skip single line comments "//..."
                if(AcceptSequence(COMMENT_BEGIN_TOKEN, SINGLELINE_COMMENT_SECOND_TOKEN))
                {
                    Skip(2);
                    ReadInputUntil(WHITESPACE_CARRIAGE_RETURN, WHITESPACE_NEWLINE);
                    commentSkipped = true;
                }

                //Skip multi line comments "/* ... */"
                else if(AcceptSequence(COMMENT_BEGIN_TOKEN, MULTILINE_COMMENT_SECOND_TOKEN))
                {
                    Skip(2);

                    while(true)
                    {
                        if(AcceptSequence(MULTILINE_COMMENT_SECOND_TOKEN, MULTILINE_COMMENT_END_TOKEN))
                        {
                            Skip(2);

                            break;
                        }

                        Skip();
                    }

                    commentSkipped = true;
                }
            } while(
                commentSkipped); //if a comment was skipped more whitespace or another comment can follow, so skip again
        }

        /// <summary>Reads input until one of the given symbols is found.</summary>
        /// <returns>The input until one the given symbols.</returns>
        /// <param name="symbols">The symbols that can occur after the string to read.</param>
        string ReadInputUntil(params char[] symbols)
        {
            string s = "";

            while(!Accept(symbols))
            {
                s += data[index];
                Skip();
            }

            return s;
        }

        /// <summary>Reads input until the given symbol is found.</summary>
        /// <returns>The input until the given symbol.</returns>
        /// <param name="symbol">The symbol that can occur after the string to read.</param>
        string ReadInputUntil(char symbol)
        {
            string s = "";

            while(!Accept(symbol))
            {
                s += data[index];
                Skip();
            }

            return s;
        }

        /// <summary>Parses the property list from the beginning and returns the root object of the property list.</summary>
        /// <returns>The root object of the property list. This can either be a NSDictionary or a NSArray.</returns>
        /// <exception cref="FormatException">When an error occured during parsing</exception>
        public NSObject Parse()
        {
            index = 0;

            //Skip Unicode byte order mark (BOM)
            if(data.Length      >= 3    &&
               (data[0] & 0xFF) == 0xEF &&
               (data[1] & 0xFF) == 0xBB &&
               (data[2] & 0xFF) == 0xBF)
                Skip(3);

            SkipWhitespacesAndComments();
            Expect(DICTIONARY_BEGIN_TOKEN, ARRAY_BEGIN_TOKEN, COMMENT_BEGIN_TOKEN);

            try
            {
                return ParseObject();
            }
            catch(IndexOutOfRangeException)
            {
                throw new FormatException($"Reached end of input unexpectedly at {index}.");
            }
        }

        /// <summary>Parses the NSObject found at the current position in the property list data stream.</summary>
        /// <returns>The parsed NSObject.</returns>
        /// <seealso cref="ASCIIPropertyListParser.index" />
        NSObject ParseObject()
        {
            switch(data[index])
            {
                case ARRAY_BEGIN_TOKEN:
                {
                    return ParseArray();
                }
                case DICTIONARY_BEGIN_TOKEN:
                {
                    return ParseDictionary();
                }
                case DATA_BEGIN_TOKEN:
                {
                    return ParseData();
                }
                case QUOTEDSTRING_BEGIN_TOKEN:
                {
                    string quotedString = ParseQuotedString();

                    //apple dates are quoted strings of length 20 and after the 4 year digits a dash is found
                    if(quotedString.Length == 20 &&
                       quotedString[4]     == DATE_DATE_FIELD_DELIMITER)
                        try
                        {
                            return new NSDate(quotedString);
                        }
                        catch(Exception)
                        {
                            //not a date? --> return string
                            return new NSString(quotedString);
                        }

                    return new NSString(quotedString);
                }
                default:
                {
                    //0-9
                    if(data[index] > 0x2F &&
                       data[index] < 0x3A)
                        return ParseDateString();

                    //non-numerical -> string or boolean
                    string parsedString = ParseString();

                    return new NSString(parsedString);
                }
            }
        }

        /// <summary>
        ///     Parses an array from the current parsing position. The prerequisite for calling this method is, that an array
        ///     begin token has been read.
        /// </summary>
        /// <returns>The array found at the parsing position.</returns>
        NSArray ParseArray()
        {
            //Skip begin token
            Skip();
            SkipWhitespacesAndComments();
            List<NSObject> objects = new();

            while(!Accept(ARRAY_END_TOKEN))
            {
                objects.Add(ParseObject());
                SkipWhitespacesAndComments();

                if(Accept(ARRAY_ITEM_DELIMITER_TOKEN))
                    Skip();
                else
                    break; //must have reached end of array

                SkipWhitespacesAndComments();
            }

            //parse end token
            Read(ARRAY_END_TOKEN);

            return new NSArray(objects.ToArray());
        }

        /// <summary>
        ///     Parses a dictionary from the current parsing position. The prerequisite for calling this method is, that a
        ///     dictionary begin token has been read.
        /// </summary>
        /// <returns>The dictionary found at the parsing position.</returns>
        NSDictionary ParseDictionary()
        {
            //Skip begin token
            Skip();
            SkipWhitespacesAndComments();
            var dict = new NSDictionary();

            while(!Accept(DICTIONARY_END_TOKEN))
            {
                //Parse key
                string keyString;

                keyString = Accept(QUOTEDSTRING_BEGIN_TOKEN) ? ParseQuotedString() : ParseString();

                SkipWhitespacesAndComments();

                //Parse assign token
                Read(DICTIONARY_ASSIGN_TOKEN);
                SkipWhitespacesAndComments();

                NSObject nso = ParseObject();
                dict.Add(keyString, nso);
                SkipWhitespacesAndComments();
                Read(DICTIONARY_ITEM_DELIMITER_TOKEN);
                SkipWhitespacesAndComments();
            }

            //skip end token
            Skip();

            return dict;
        }

        /// <summary>
        ///     Parses a data object from the current parsing position. This can either be a NSData object or a GnuStep
        ///     NSNumber or NSDate. The prerequisite for calling this method is, that a data begin token has been read.
        /// </summary>
        /// <returns>The data object found at the parsing position.</returns>
        NSObject ParseData()
        {
            NSObject obj = null;

            //Skip begin token
            Skip();

            if(Accept(DATA_GSOBJECT_BEGIN_TOKEN))
            {
                Skip();

                Expect(DATA_GSBOOL_BEGIN_TOKEN, DATA_GSDATE_BEGIN_TOKEN, DATA_GSINT_BEGIN_TOKEN,
                       DATA_GSREAL_BEGIN_TOKEN);

                if(Accept(DATA_GSBOOL_BEGIN_TOKEN))
                {
                    //Boolean
                    Skip();
                    Expect(DATA_GSBOOL_TRUE_TOKEN, DATA_GSBOOL_FALSE_TOKEN);

                    if(Accept(DATA_GSBOOL_TRUE_TOKEN))
                        obj = new NSNumber(true);
                    else
                        obj = new NSNumber(false);

                    //Skip the parsed boolean token
                    Skip();
                }
                else if(Accept(DATA_GSDATE_BEGIN_TOKEN))
                {
                    //Date
                    Skip();
                    string dateString = ReadInputUntil(DATA_END_TOKEN);
                    obj = new NSDate(dateString);
                }
                else if(Accept(DATA_GSINT_BEGIN_TOKEN, DATA_GSREAL_BEGIN_TOKEN))
                {
                    //Number
                    Skip();
                    string numberString = ReadInputUntil(DATA_END_TOKEN);
                    obj = new NSNumber(numberString);
                }

                //parse data end token
                Read(DATA_END_TOKEN);
            }
            else
            {
                string dataString = ReadInputUntil(DATA_END_TOKEN);
                dataString = Regex.Replace(dataString, "\\s+", "");

                int    numBytes = dataString.Length / 2;
                byte[] bytes    = new byte[numBytes];

                for(int i = 0; i < bytes.Length; i++)
                {
                    string byteString = dataString.Substring(i * 2, 2);
                    int    byteValue  = Convert.ToInt32(byteString, 16);
                    bytes[i] = (byte)byteValue;
                }

                obj = new NSData(bytes);

                //skip end token
                Skip();
            }

            return obj;
        }

        /// <summary>Attempts to parse a plain string as a date if possible.</summary>
        /// <returns>A NSDate if the string represents such an object. Otherwise a NSString is returned.</returns>
        NSObject ParseDateString()
        {
            string numericalString = ParseString();

            if(numericalString.Length <= 4 ||
               numericalString[4]     != DATE_DATE_FIELD_DELIMITER)
                return new NSString(numericalString);

            try
            {
                return new NSDate(numericalString);
            }
            catch(Exception)
            {
                //An exception occurs if the string is not a date but just a string
            }

            return new NSString(numericalString);
        }

        /// <summary>
        ///     Parses a plain string from the current parsing position. The string is made up of all characters to the next
        ///     whitespace, delimiter token or assignment token.
        /// </summary>
        /// <returns>The string found at the current parsing position.</returns>
        string ParseString() => ReadInputUntil(WHITESPACE_SPACE, WHITESPACE_TAB, WHITESPACE_NEWLINE,
                                               WHITESPACE_CARRIAGE_RETURN, ARRAY_ITEM_DELIMITER_TOKEN,
                                               DICTIONARY_ITEM_DELIMITER_TOKEN, DICTIONARY_ASSIGN_TOKEN,
                                               ARRAY_END_TOKEN);

        /// <summary>
        ///     Parses a quoted string from the current parsing position. The prerequisite for calling this method is, that a
        ///     quoted string begin token has been read.
        /// </summary>
        /// <returns>The quoted string found at the parsing method with all special characters unescaped.</returns>
        /// <exception cref="FormatException">If an error occured during parsing.</exception>
        string ParseQuotedString()
        {
            //Skip begin token
            Skip();
            string quotedString       = "";
            bool   unescapedBackslash = true;

            //Read from opening quotation marks to closing quotation marks and skip escaped quotation marks
            while(data[index] != QUOTEDSTRING_END_TOKEN ||
                  (data[index - 1] == QUOTEDSTRING_ESCAPE_TOKEN && unescapedBackslash))
            {
                quotedString += data[index];

                if(Accept(QUOTEDSTRING_ESCAPE_TOKEN))
                    unescapedBackslash = !(data[index - 1] == QUOTEDSTRING_ESCAPE_TOKEN && unescapedBackslash);

                Skip();
            }

            string unescapedString;

            try
            {
                unescapedString = ParseQuotedString(quotedString);
            }
            catch(Exception)
            {
                throw new FormatException($"The quoted string could not be parsed at {index}.");
            }

            //skip end token
            Skip();

            return unescapedString;
        }

        /// <summary>
        ///     Parses a string according to the format specified for ASCII property lists. Such strings can contain escape
        ///     sequences which are unescaped in this method.
        /// </summary>
        /// <returns>The unescaped string in UTF-8 or ASCII format, depending on the contained characters.</returns>
        /// <param name="s">
        ///     The escaped string according to the ASCII property list format, without leading and trailing quotation
        ///     marks.
        /// </param>
        /// <exception cref="ArgumentException">If the en-/decoder for the UTF-8 or ASCII encoding could not be loaded</exception>
        /// <exception cref="EncoderFallbackException">If the string is encoded neither in ASCII nor in UTF-8</exception>
        public static string ParseQuotedString(string s)
        {
            List<byte> strBytes = new();

            IEnumerable<char> characters = s.ToCharArray();
            IEnumerator<char> c          = characters.GetEnumerator();

            while(c.MoveNext())
                switch(c.Current)
                {
                    case '\\':
                    {
                        //An escaped sequence is following
                        byte[] bts = Encoding.UTF8.GetBytes(ParseEscapedSequence(c));

                        foreach(byte b in bts)
                            strBytes.Add(b);

                        break;
                    }
                    default:
                    {
                        //a normal ASCII char
                        strBytes.AddRange(Encoding.BigEndianUnicode.GetBytes(new[]
                        {
                            c.Current
                        }));

                        break;
                    }
                }

            byte[] bytArr = new byte[strBytes.Count];
            int    i      = 0;

            foreach(byte b in strBytes)
            {
                bytArr[i] = b;
                i++;
            }

            //Build string
            string result = Encoding.BigEndianUnicode.GetString(bytArr);

            //If the string can be represented in the ASCII codepage
            // --> use ASCII encoding
            if(IsASCIIEncodable(result))
                return Encoding.ASCII.GetString(Encoding.Convert(Encoding.BigEndianUnicode, Encoding.ASCII, bytArr));

            //The string contains characters outside the ASCII codepage
            // --> use the UTF-8 encoded string
            return result;
        }

        /// <summary>Unescapes an escaped character sequence, e.g. \\u00FC.</summary>
        /// <returns>The unescaped character as a string.</returns>
        /// <param name="iterator">The string character iterator pointing to the first character after the backslash</param>
        /// <exception cref="EncoderFallbackException">If an invalid Unicode or ASCII escape sequence is found.</exception>
        static string ParseEscapedSequence(IEnumerator<char> iterator)
        {
            iterator.MoveNext();
            char c = iterator.Current;

            switch(c)
            {
                case '\\':
                    return Encoding.UTF8.GetString(new byte[]
                    {
                        0, (byte)'\\'
                    });
                case '"':
                    return Encoding.UTF8.GetString(new byte[]
                    {
                        0, (byte)'\"'
                    });
                case 'b':
                    return Encoding.UTF8.GetString(new byte[]
                    {
                        0, (byte)'\b'
                    });
                case 'n':
                    return Encoding.UTF8.GetString(new byte[]
                    {
                        0, (byte)'\n'
                    });
                case 'r':
                    return Encoding.UTF8.GetString(new byte[]
                    {
                        0, (byte)'\r'
                    });
                case 't':
                    return Encoding.UTF8.GetString(new byte[]
                    {
                        0, (byte)'\t'
                    });
                case 'U':
                case 'u':
                {
                    //4 digit hex Unicode value
                    string byte1 = "";
                    iterator.MoveNext();
                    byte1 += iterator.Current;
                    iterator.MoveNext();
                    byte1 += iterator.Current;
                    string byte2 = "";
                    iterator.MoveNext();
                    byte2 += iterator.Current;
                    iterator.MoveNext();
                    byte2 += iterator.Current;

                    byte[] stringBytes =
                    {
                        (byte)Convert.ToInt32(byte1, 16), (byte)Convert.ToInt32(byte2, 16)
                    };

                    return Encoding.UTF8.GetString(stringBytes);
                }
                default:
                {
                    //3 digit octal ASCII value
                    string num = "";
                    num += c;
                    iterator.MoveNext();
                    num += iterator.Current;
                    iterator.MoveNext();
                    num += iterator.Current;
                    int asciiCode = Convert.ToInt32(num, 8);

                    byte[] stringBytes =
                    {
                        0, (byte)asciiCode
                    };

                    return Encoding.UTF8.GetString(stringBytes);
                }
            }
        }

        internal static bool IsASCIIEncodable(string text)
        {
            foreach(char c in text)
                if(c > 0x7F)
                    return false;

            return true;
        }
    }
}

// BinaryPropertyListParser.cs
namespace Squirrel.Packaging.OSX
{
    /// <summary>
    ///     <para>
    ///         Parses property lists that are in Apple's binary format. Use this class when you are sure about the format of
    ///         the property list. Otherwise use the PropertyListParser class.
    ///     </para>
    ///     <para>
    ///         Parsing is done by calling the static <see cref="Parse(byte[])" />, <see cref="Parse(FileInfo)" /> and
    ///         <see cref="Parse(Stream)" /> methods.
    ///     </para>
    /// </summary>
    /// @author Daniel Dreibrodt
    /// @author Natalia Portillo
    internal class BinaryPropertyListParser
    {
        static readonly Encoding utf16BigEndian = Encoding.GetEncoding("UTF-16BE");

        /// <summary>Major version of the property list format</summary>
        int majorVersion;

        /// <summary>Minor version of the property list format</summary>
        int minorVersion;

        /// <summary>Length of an object reference in bytes</summary>
        int objectRefSize;

        /// <summary>The table holding the information at which offset each object is found</summary>
        int[] offsetTable;

        /// <summary>Protected constructor so that instantiation is fully controlled by the static parse methods.</summary>
        /// <see cref="Parse(byte[])" />
        protected BinaryPropertyListParser() {}

        /// <summary>Parses a binary property list from a byte array.</summary>
        /// <param name="data">The binary property list's data.</param>
        /// <returns>The root object of the property list. This is usually a NSDictionary but can also be a NSArray.</returns>
        /// <exception cref="PropertyListFormatException">When the property list's format could not be parsed.</exception>
        public static NSObject Parse(byte[] data) => Parse(data.AsSpan());

        /// <summary>Parses a binary property list from a byte array.</summary>
        /// <param name="data">The binary property list's data.</param>
        /// <param name="offset">The offset at which to start reading the property list.</param>
        /// <param name="length">The length of the property list.</param>
        /// <returns>The root object of the property list. This is usually a NSDictionary but can also be a NSArray.</returns>
        /// <exception cref="PropertyListFormatException">When the property list's format could not be parsed.</exception>
        public static NSObject Parse(byte[] data, int offset, int length) => Parse(data.AsSpan(offset, length));

        /// <summary>Parses a binary property list from a byte span.</summary>
        /// <param name="data">The binary property list's data.</param>
        /// <returns>The root object of the property list. This is usually a NSDictionary but can also be a NSArray.</returns>
        /// <exception cref="PropertyListFormatException">When the property list's format could not be parsed.</exception>
        public static NSObject Parse(ReadOnlySpan<byte> data)
        {
            var parser = new BinaryPropertyListParser();

            return parser.DoParse(data);
        }

        /// <summary>Parses a binary property list from a byte array.</summary>
        /// <returns>The root object of the property list. This is usually a NSDictionary but can also be a NSArray.</returns>
        /// <param name="bytes">The binary property list's data.</param>
        /// <exception cref="PropertyListFormatException">When the property list's format could not be parsed.</exception>
        protected NSObject DoParse(ReadOnlySpan<byte> bytes)
        {
            if(bytes.Length < 8    ||
               bytes[0]     != 'b' ||
               bytes[1]     != 'p' ||
               bytes[2]     != 'l' ||
               bytes[3]     != 'i' ||
               bytes[4]     != 's' ||
               bytes[5]     != 't')
            {
                string magic = Encoding.ASCII.GetString(bytes.Slice(0, 8).ToArray());

                throw new PropertyListFormatException("The given data is no binary property list. Wrong magic bytes: " +
                                                      magic);
            }

            majorVersion = bytes[6] - 0x30; //ASCII number
            minorVersion = bytes[7] - 0x30; //ASCII number

            // 0.0 - OS X Tiger and earlier
            // 0.1 - Leopard
            // 0.? - Snow Leopard
            // 1.5 - Lion
            // 2.0 - Snow Lion

            if(majorVersion > 0)
                throw new PropertyListFormatException("Unsupported binary property list format: v" + majorVersion +
                                                      "." + minorVersion + ". " +
                                                      "Version 1.0 and later are not yet supported.");

            /*
             * Handle trailer, last 32 bytes of the file
             */
            ReadOnlySpan<byte> trailer = bytes.Slice(bytes.Length - 32, 32);

            //6 null bytes (index 0 to 5)
            int offsetSize = trailer[6];
            objectRefSize = trailer[7];
            int numObjects        = (int)BinaryPrimitives.ReadUInt64BigEndian(trailer.Slice(8, 8));
            int topObject         = (int)BinaryPrimitives.ReadUInt64BigEndian(trailer.Slice(16, 8));
            int offsetTableOffset = (int)BinaryPrimitives.ReadUInt64BigEndian(trailer.Slice(24, 8));

            /*
             * Handle offset table
             */
            offsetTable = new int[numObjects];

            for(int i = 0; i < numObjects; i++)
            {
                ReadOnlySpan<byte> offsetBytes = bytes.Slice(offsetTableOffset + (i * offsetSize), offsetSize);
                offsetTable[i] = (int)ParseUnsignedInt(offsetBytes);
            }

            return ParseObject(bytes, topObject);
        }

        /// <summary>Parses a binary property list from an input stream.</summary>
        /// <param name="fs">The input stream that points to the property list's data.</param>
        /// <returns>The root object of the property list. This is usually a NSDictionary but can also be a NSArray.</returns>
        /// <exception cref="PropertyListFormatException">When the property list's format could not be parsed.</exception>
        public static NSObject Parse(Stream fs)
        {
            //Read all bytes into a list
            byte[] buf = PropertyListParser.ReadAll(fs);

            // Don't close the stream - that would be the responisibility of code that class
            // Parse
            return Parse(buf);
        }

        /// <summary>Parses a binary property list file.</summary>
        /// <param name="f">The binary property list file</param>
        /// <returns>The root object of the property list. This is usually a NSDictionary but can also be a NSArray.</returns>
        /// <exception cref="PropertyListFormatException">When the property list's format could not be parsed.</exception>
        public static NSObject Parse(FileInfo f) => Parse(f.OpenRead());

        protected int GetOffset(int obj) => offsetTable[obj];

        /// <summary>
        ///     Parses an object inside the currently parsed binary property list. For the format specification check
        ///     <a href="http://www.opensource.apple.com/source/CF/CF-855.17/CFBinaryPList.c">
        ///         Apple's binary property list parser
        ///         implementation
        ///     </a>
        ///     .
        /// </summary>
        /// <returns>The parsed object.</returns>
        /// <param name="obj">The object ID.</param>
        /// <exception cref="PropertyListFormatException">When the property list's format could not be parsed.</exception>
        protected virtual NSObject ParseObject(ReadOnlySpan<byte> bytes, int obj)
        {
            int  offset  = offsetTable[obj];
            byte type    = bytes[offset];
            int  objType = (type & 0xF0) >> 4; //First  4 bits
            int  objInfo = type & 0x0F;        //Second 4 bits

            switch(objType)
            {
                case 0x0:
                {
                    //Simple
                    switch(objInfo)
                    {
                        case 0x0:
                        {
                            //null object (v1.0 and later)
                            return null;
                        }
                        case 0x8:
                        {
                            //false
                            return new NSNumber(false);
                        }
                        case 0x9:
                        {
                            //true
                            return new NSNumber(true);
                        }
                        case 0xC:
                        {
                            //URL with no base URL (v1.0 and later)
                            //TODO Implement binary URL parsing (not yet even implemented in Core Foundation as of revision 855.17)
                            break;
                        }
                        case 0xD:
                        {
                            //URL with base URL (v1.0 and later)
                            //TODO Implement binary URL parsing (not yet even implemented in Core Foundation as of revision 855.17)
                            break;
                        }
                        case 0xE:
                        {
                            //16-byte UUID (v1.0 and later)
                            //TODO Implement binary UUID parsing (not yet even implemented in Core Foundation as of revision 855.17)
                            break;
                        }
                        case 0xF:
                        {
                            //filler byte
                            return null;
                        }
                    }

                    break;
                }
                case 0x1:
                {
                    //integer
                    int length = 1 << objInfo;

                    return new NSNumber(bytes.Slice(offset + 1, length), NSNumber.INTEGER);
                }
                case 0x2:
                {
                    //real
                    int length = 1 << objInfo;

                    return new NSNumber(bytes.Slice(offset + 1, length), NSNumber.REAL);
                }
                case 0x3:
                {
                    //Date
                    if(objInfo != 0x3)
                        throw new
                            PropertyListFormatException("The given binary property list contains a date object of an unknown type (" +
                                                        objInfo + ")");

                    return new NSDate(bytes.Slice(offset + 1, 8));
                }
                case 0x4:
                {
                    //Data
                    ReadLengthAndOffset(bytes, objInfo, offset, out int length, out int dataoffset);

                    return new NSData(CopyOfRange(bytes, offset + dataoffset, offset + dataoffset + length));
                }
                case 0x5:
                {
                    //ASCII String, each character is 1 byte
                    ReadLengthAndOffset(bytes, objInfo, offset, out int length, out int stroffset);

                    return new NSString(bytes.Slice(offset + stroffset, length), Encoding.ASCII);
                }
                case 0x6:
                {
                    //UTF-16-BE String
                    ReadLengthAndOffset(bytes, objInfo, offset, out int length, out int stroffset);

                    //UTF-16 characters can have variable length, but the Core Foundation reference implementation
                    //assumes 2 byte characters, thus only covering the Basic Multilingual Plane
                    length *= 2;

                    return new NSString(bytes.Slice(offset + stroffset, length), utf16BigEndian);
                }
                case 0x7:
                {
                    //UTF-8 string (v1.0 and later)
                    ReadLengthAndOffset(bytes, objInfo, offset, out int strOffset, out int characters);

                    //UTF-8 characters can have variable length, so we need to calculate the byte length dynamically
                    //by reading the UTF-8 characters one by one
                    int length = CalculateUtf8StringLength(bytes, offset + strOffset, characters);

                    return new NSString(bytes.Slice(offset + strOffset, length), Encoding.UTF8);
                }
                case 0x8:
                {
                    //UID (v1.0 and later)
                    int length = objInfo + 1;

                    return new UID(bytes.Slice(offset + 1, length));
                }
                case 0xA:
                {
                    //Array
                    ReadLengthAndOffset(bytes, objInfo, offset, out int length, out int arrayOffset);

                    var array = new NSArray(length);

                    for(int i = 0; i < length; i++)
                    {
                        int objRef =
                            (int)ParseUnsignedInt(bytes.Slice(offset + arrayOffset + (i * objectRefSize),
                                                              objectRefSize));

                        array.Add(ParseObject(bytes, objRef));
                    }

                    return array;
                }
                case 0xB:
                {
                    //Ordered set (v1.0 and later)
                    ReadLengthAndOffset(bytes, objInfo, offset, out int length, out int contentOffset);

                    var set = new NSSet(true);

                    for(int i = 0; i < length; i++)
                    {
                        int objRef =
                            (int)ParseUnsignedInt(bytes.Slice(offset + contentOffset + (i * objectRefSize),
                                                              objectRefSize));

                        set.AddObject(ParseObject(bytes, objRef));
                    }

                    return set;
                }
                case 0xC:
                {
                    //Set (v1.0 and later)
                    ReadLengthAndOffset(bytes, objInfo, offset, out int length, out int contentOffset);

                    var set = new NSSet();

                    for(int i = 0; i < length; i++)
                    {
                        int objRef =
                            (int)ParseUnsignedInt(bytes.Slice(offset + contentOffset + (i * objectRefSize),
                                                              objectRefSize));

                        set.AddObject(ParseObject(bytes, objRef));
                    }

                    return set;
                }
                case 0xD:
                {
                    //Dictionary
                    ReadLengthAndOffset(bytes, objInfo, offset, out int length, out int contentOffset);

                    //System.out.println("Parsing dictionary #"+obj);
                    var dict = new NSDictionary(length);

                    for(int i = 0; i < length; i++)
                    {
                        int keyRef =
                            (int)ParseUnsignedInt(bytes.Slice(offset + contentOffset + (i * objectRefSize),
                                                              objectRefSize));

                        int valRef =
                            (int)
                            ParseUnsignedInt(bytes.Slice(offset + contentOffset + (length * objectRefSize) + (i * objectRefSize),
                                                         objectRefSize));

                        NSObject key = ParseObject(bytes, keyRef);
                        NSObject val = ParseObject(bytes, valRef);
                        dict.Add(key.ToString(), val);
                    }

                    return dict;
                }
                default:
                {
                    Debug.WriteLine("WARNING: The given binary property list contains an object of unknown type (" +
                                    objType + ")");

                    break;
                }
            }

            return null;
        }

        /// <summary>Reads the length for arrays, sets and dictionaries.</summary>
        /// <returns>An array with the length two. First entry is the length, second entry the offset at which the content starts.</returns>
        /// <param name="objInfo">Object information byte.</param>
        /// <param name="offset">Offset in the byte array at which the object is located.</param>
        void ReadLengthAndOffset(ReadOnlySpan<byte> bytes, int objInfo, int offset, out int lengthValue,
                                 out int offsetValue)
        {
            lengthValue = objInfo;
            offsetValue = 1;

            if(objInfo == 0xF)
            {
                int int_type = bytes[offset + 1];
                int intType  = (int_type & 0xF0) >> 4;

                if(intType != 0x1)
                    Debug.WriteLine("BinaryPropertyListParser: Length integer has an unexpected type" + intType +
                                    ". Attempting to parse anyway...");

                int intInfo   = int_type & 0x0F;
                int intLength = 1 << intInfo;
                offsetValue = 2 + intLength;

                if(intLength < 3)
                    lengthValue = (int)ParseUnsignedInt(bytes.Slice(offset + 2, intLength));
                else
                {
                    // BigInteger is Little-Endian in .NET, swap the thing.
                    // Also BigInteger is of .NET 4.0, maybe there's a better way to do it.
                    byte[] bigEBigInteger = bytes.Slice(offset + 2, intLength).ToArray();
                    Array.Reverse(bigEBigInteger);
                    bigEBigInteger[bigEBigInteger.Length - 1] = 0x00; // Be sure to get unsigned BigInteger

                    lengthValue = (int)new BigInteger(bigEBigInteger);
                }
            }
        }

        /// <summary>Calculates the length in bytes of the UTF-8 string.</summary>
        /// <returns>The UTF-8 string length.</returns>
        /// <param name="bytes">Array containing the UTF-8 string.</param>
        /// <param name="offset">Offset in the array where the UTF-8 string resides.</param>
        /// <param name="numCharacters">How many UTF-8 characters are in the string.</param>
        int CalculateUtf8StringLength(ReadOnlySpan<byte> bytes, int offset, int numCharacters)
        {
            int length = 0;

            for(int i = 0; i < numCharacters; i++)
            {
                int tempOffset = offset + length;

                if(bytes.Length <= tempOffset)
                    return numCharacters;

                if(bytes[tempOffset] < 0x80)
                    length++;

                if(bytes[tempOffset] < 0xC2)
                    return numCharacters;

                if(bytes[tempOffset] < 0xE0)
                {
                    if((bytes[tempOffset + 1] & 0xC0) != 0x80)
                        return numCharacters;

                    length += 2;
                }
                else if(bytes[tempOffset] < 0xF0)
                {
                    if((bytes[tempOffset + 1] & 0xC0) != 0x80 ||
                       (bytes[tempOffset + 2] & 0xC0) != 0x80)
                        return numCharacters;

                    length += 3;
                }
                else if(bytes[tempOffset] < 0xF5)
                {
                    if((bytes[tempOffset + 1] & 0xC0) != 0x80 ||
                       (bytes[tempOffset + 2] & 0xC0) != 0x80 ||
                       (bytes[tempOffset + 3] & 0xC0) != 0x80)
                        return numCharacters;

                    length += 4;
                }
            }

            return length;
        }

        /// <summary>Parses an unsigned integer from a span.</summary>
        /// <returns>The byte array containing the unsigned integer.</returns>
        /// <param name="bytes">The unsigned integer represented by the given bytes.</param>
        public static long ParseUnsignedInt(ReadOnlySpan<byte> bytes)
        {
            if(bytes.Length <= 4)
                return ParseLong(bytes);

            return ParseLong(bytes) & 0xFFFFFFFFL;
        }

        /// <summary>Parses an unsigned integers from a byte array.</summary>
        /// <returns>The byte array containing the unsigned integer.</returns>
        /// <param name="bytes">The unsigned integer represented by the given bytes.</param>
        public static long ParseUnsignedInt(byte[] bytes) => ParseUnsignedInt(bytes.AsSpan());

        /// <summary>Parses a long from a (big-endian) byte array.</summary>
        /// <returns>The long integer represented by the given bytes.</returns>
        /// <param name="bytes">The bytes representing the long integer.</param>
        public static long ParseLong(ReadOnlySpan<byte> bytes)
        {
            if(bytes == null)
            {
                throw new ArgumentNullException(nameof(bytes));
            }

            if(bytes.Length == 0)
            {
                throw new ArgumentOutOfRangeException(nameof(bytes));
            }

            // https://opensource.apple.com/source/CF/CF-1153.18/CFBinaryPList.c,
            // __CFBinaryPlistCreateObjectFiltered, case kCFBinaryPlistMarkerInt:
            //
            // in format version '00', 1, 2, and 4-byte integers have to be interpreted as unsigned,
            // whereas 8-byte integers are signed (and 16-byte when available)
            // negative 1, 2, 4-byte integers are always emitted as 8 bytes in format '00'
            // integers are not required to be in the most compact possible representation,
            // but only the last 64 bits are significant currently
            switch(bytes.Length)
            {
                case 1: return bytes[0];

                case 2: return BinaryPrimitives.ReadUInt16BigEndian(bytes);

                case 4: return BinaryPrimitives.ReadUInt32BigEndian(bytes);

                // Transition from unsigned to signed
                case 8: return BinaryPrimitives.ReadInt64BigEndian(bytes);

                // Only the last 64 bits are significant currently
                case 16: return BinaryPrimitives.ReadInt64BigEndian(bytes.Slice(8));
            }

            if(bytes.Length >= 8)
                throw new ArgumentOutOfRangeException(nameof(bytes),
                                                      $"Cannot read a byte span of length {bytes.Length}");

            // Compatibility with existing archives, including anything with a non-power-of-2
            // size and 16-byte values, and architectures that don't support unaligned access
            long value = 0;

            for(int i = 0; i < bytes.Length; i++)
            {
                value = (value << 8) + bytes[i];
            }

            return value;

            // Theoretically we could handle non-power-of-2 byte arrays larger than 8, with the code
            // above, and it appears the reference implementation does exactly that. But it seems to
            // be an extreme edge case.
        }

        /// <summary>Parses a double from a (big-endian) byte array.</summary>
        /// <returns>The double represented by the given bytes.</returns>
        /// <param name="bytes">The bytes representing the double.</param>
        public static double ParseDouble(ReadOnlySpan<byte> bytes)
        {
            if(bytes == null)
            {
                throw new ArgumentNullException(nameof(bytes));
            }

            return bytes.Length switch
            {
                8 => BitConverter.Int64BitsToDouble(ParseLong(bytes)),
                4 => BitConverter.ToSingle(BitConverter.GetBytes(ParseLong(bytes)), 0),
                _ => throw new ArgumentException("bad byte array length " + bytes.Length)
            };
        }

        /// <summary>Copies a part of a byte array into a new array.</summary>
        /// <returns>The copied array.</returns>
        /// <param name="src">The source array.</param>
        /// <param name="startIndex">The index from which to start copying.</param>
        /// <param name="endIndex">The index until which to copy.</param>
        public static byte[] CopyOfRange(ReadOnlySpan<byte> src, int startIndex, int endIndex)
        {
            int length = endIndex - startIndex;

            if(length < 0)
                throw new ArgumentOutOfRangeException("startIndex (" + startIndex + ")" + " > endIndex (" + endIndex +
                                                      ")");

            return src.Slice(startIndex, endIndex - startIndex).ToArray();
        }
    }
}

// BinaryPropertyListWriter.AddObjectEqualityComparer.cs
namespace Squirrel.Packaging.OSX
{
    internal partial class BinaryPropertyListWriter
    {

        /// <summary>
        ///     The equality comparer which is used when adding an object to the <see cref="BinaryPropertyListWriter.idMap" />
        ///     . In most cases, objects are always added. The only exception are very specific strings, which are only added once.
        /// </summary>
        class AddObjectEqualityComparer : EqualityComparer<NSObject>
        {
            public override bool Equals(NSObject x, NSObject y)
            {
                if(x is not NSString a ||
                   y is not NSString b)
                    return ReferenceEquals(x, y);

                if(!IsSerializationPrimitive(a) ||
                   !IsSerializationPrimitive(b))
                    return ReferenceEquals(x, y);

                return string.Equals(a.Content, b.Content, StringComparison.Ordinal);
            }

            public override int GetHashCode(NSObject obj)
            {
                if(obj is NSString s &&
                   IsSerializationPrimitive(s))
                    return s.Content.GetHashCode();

                return obj.GetHashCode();
            }
        }
    }
}

// BinaryPropertyListWriter.cs
namespace Squirrel.Packaging.OSX
{
    /// <summary>
    ///     <para>A BinaryPropertyListWriter is a helper class for writing out binary property list files.</para>
    ///     <para>
    ///         It contains an output stream and various structures for keeping track of which NSObjects have already been
    ///         serialized, and where they were put in the file.
    ///     </para>
    /// </summary>
    /// @author Keith Randall
    /// @author Natalia Portillo
    internal partial class BinaryPropertyListWriter
    {
        /// <summary>Binary property list version 0.0</summary>
        public const int VERSION_00 = 0;
        /// <summary>Binary property list version 1.0</summary>
        public const int VERSION_10 = 10;
        /// <summary>Binary property list version 1.5</summary>
        public const int VERSION_15 = 15;
        /// <summary>Binary property list version 2.0</summary>
        public const int VERSION_20 = 20;

        // map from object to its ID
        protected readonly Dictionary<NSObject, int> idDict  = new(new AddObjectEqualityComparer());
        protected readonly Dictionary<NSObject, int> idDict2 = new(new GetObjectEqualityComparer());

        // raw output stream to result file
        readonly Stream outStream;

        readonly int version = VERSION_00;

        // # of bytes written so far
        long          count;
        protected int currentId;
        int           idSizeInBytes;

        /// <summary>Creates a new binary property list writer</summary>
        /// <param name="outStr">The output stream into which the binary property list will be written</param>
        /// <exception cref="IOException">If an error occured while writing to the stream</exception>
        public BinaryPropertyListWriter(Stream outStr) => outStream = outStr;

        public BinaryPropertyListWriter(Stream outStr, int version)
        {
            this.version = version;
            outStream    = outStr;
        }

        public BinaryPropertyListWriter(Stream outStr, int version,
                                        IEqualityComparer<NSObject> addObjectEqualityComparer,
                                        IEqualityComparer<NSObject> getObjectEqualityComparer)
        {
            this.version = version;
            outStream    = outStr;
            idDict       = new Dictionary<NSObject, int>(addObjectEqualityComparer);
            idDict2      = new Dictionary<NSObject, int>(getObjectEqualityComparer);
        }

        /// <summary>
        ///     Gets or sets a value indicating whether two equivalent objects should be serialized once in the binary
        ///     property list file, or whether the value should be stored multiple times in the binary property list file. The
        ///     default is <see langword="false" /> .
        /// </summary>
        /// <remarks>
        ///     In most scenarios, you want this to be <see langword="true" />, as it reduces the size of the binary proeprty
        ///     list file. However, by default, the Apple tools do not seem to implement this optimization, so set this value to
        ///     <see langword="false" /> if you want to maintain binary compatibility with the Apple tools.
        /// </remarks>
        public bool ReuseObjectIds { get; set; }

        /// <summary>Finds out the minimum binary property list format version that can be used to save the given NSObject tree.</summary>
        /// <returns>Version code</returns>
        /// <param name="root">Object root.</param>
        static int GetMinimumRequiredVersion(NSObject root)
        {
            int minVersion = VERSION_00;

            switch(root)
            {
                case null:
                    minVersion = VERSION_10;

                    break;
                case NSDictionary dict:
                {
                    foreach(NSObject o in dict.GetDictionary().Values)
                    {
                        int v = GetMinimumRequiredVersion(o);

                        if(v > minVersion)
                            minVersion = v;
                    }

                    break;
                }
                case NSArray array:
                {
                    foreach(NSObject o in array)
                    {
                        int v = GetMinimumRequiredVersion(o);

                        if(v > minVersion)
                            minVersion = v;
                    }

                    break;
                }
                case NSSet set:
                {
                    //Sets are only allowed in property lists v1+
                    minVersion = VERSION_10;

                    foreach(NSObject o in set.AllObjects())
                    {
                        int v = GetMinimumRequiredVersion(o);

                        if(v > minVersion)
                            minVersion = v;
                    }

                    break;
                }
            }

            return minVersion;
        }

        /// <summary>Writes a binary plist file with the given object as the root.</summary>
        /// <param name="file">the file to write to</param>
        /// <param name="root">the source of the data to write to the file</param>
        /// <exception cref="IOException"></exception>
        public static void Write(FileInfo file, NSObject root)
        {
            using FileStream fous = file.OpenWrite();

            Write(fous, root);
        }

        /// <summary>Writes a binary plist serialization of the given object as the root.</summary>
        /// <param name="outStream">the stream to write to</param>
        /// <param name="root">the source of the data to write to the stream</param>
        /// <exception cref="IOException"></exception>
        public static void Write(Stream outStream, NSObject root)
        {
            int minVersion = GetMinimumRequiredVersion(root);

            if(minVersion > VERSION_00)
            {
                string versionString = minVersion == VERSION_10
                                           ? "v1.0"
                                           : minVersion == VERSION_15
                                               ? "v1.5"
                                               : minVersion == VERSION_20
                                                   ? "v2.0"
                                                   : "v0.0";

                throw new IOException("The given property list structure cannot be saved. " +
                                      "The required version of the binary format ("         + versionString +
                                      ") is not yet supported.");
            }

            var w = new BinaryPropertyListWriter(outStream, minVersion);
            w.Write(root);
        }

        /// <summary>Writes a binary plist serialization of the given object as the root into a byte array.</summary>
        /// <returns>The byte array containing the serialized property list</returns>
        /// <param name="root">The root object of the property list</param>
        /// <exception cref="IOException"></exception>
        public static byte[] WriteToArray(NSObject root)
        {
            var bout = new MemoryStream();
            Write(bout, root);

            return bout.ToArray();
        }

        public void Write(NSObject root)
        {
            // magic bytes
            Write(new[]
            {
                (byte)'b', (byte)'p', (byte)'l', (byte)'i', (byte)'s', (byte)'t'
            });

            //version
            switch(version)
            {
                case VERSION_00:
                {
                    Write(new[]
                    {
                        (byte)'0', (byte)'0'
                    });

                    break;
                }
                case VERSION_10:
                {
                    Write(new[]
                    {
                        (byte)'1', (byte)'0'
                    });

                    break;
                }
                case VERSION_15:
                {
                    Write(new[]
                    {
                        (byte)'1', (byte)'5'
                    });

                    break;
                }
                case VERSION_20:
                {
                    Write(new[]
                    {
                        (byte)'2', (byte)'0'
                    });

                    break;
                }
            }

            // assign IDs to all the objects.
            root.AssignIDs(this);

            idSizeInBytes = ComputeIdSizeInBytes(idDict.Count);

            // offsets of each object, indexed by ID
            long[] offsets = new long[idDict.Count];

            // write each object, save offset
            foreach(KeyValuePair<NSObject, int> pair in idDict)
            {
                NSObject obj = pair.Key;
                int      id  = pair.Value;
                offsets[id] = count;

                if(obj == null)
                    Write(0x00);
                else
                    obj.ToBinary(this);
            }

            // write offset table
            long offsetTableOffset = count;
            int  offsetSizeInBytes = ComputeOffsetSizeInBytes(count);

            foreach(long offset in offsets)
                WriteBytes(offset, offsetSizeInBytes);

            if(version != VERSION_15)
            {
                // write trailer
                // 6 null bytes
                Write(new byte[6]);

                // size of an offset
                Write(offsetSizeInBytes);

                // size of a ref
                Write(idSizeInBytes);

                // number of objects
                WriteLong(idDict.Count);

                // top object
                int rootID = idDict[root];
                WriteLong(rootID);

                // offset table offset
                WriteLong(offsetTableOffset);
            }

            outStream.Flush();
        }

        protected internal virtual void AssignID(NSObject obj)
        {
            if(ReuseObjectIds)
            {
                if(!idDict.ContainsKey(obj))
                    idDict.Add(obj, currentId++);
            }
            else
            {
                if(!idDict2.ContainsKey(obj))
                    idDict2.Add(obj, currentId);

                if(!idDict.ContainsKey(obj))
                    idDict.Add(obj, currentId++);
            }
        }

        internal int GetID(NSObject obj) => ReuseObjectIds ? idDict[obj] : idDict2[obj];

        static int ComputeIdSizeInBytes(int numberOfIds)
        {
            if(numberOfIds < 256)
                return 1;

            return numberOfIds < 65536 ? 2 : 4;
        }

        static int ComputeOffsetSizeInBytes(long maxOffset) => maxOffset switch
        {
            < 256         => 1,
            < 65536       => 2,
            < 4294967296L => 4,
            _             => 8
        };

        internal void WriteIntHeader(int kind, int value)
        {
            switch(value)
            {
                case < 0: throw new ArgumentException("value must be greater than or equal to 0", "value");
                case < 15:
                    Write((kind << 4) + value);

                    break;
                case < 256:
                    Write((kind << 4) + 15);
                    Write(0x10);
                    WriteBytes(value, 1);

                    break;
                case < 65536:
                    Write((kind << 4) + 15);
                    Write(0x11);
                    WriteBytes(value, 2);

                    break;
                default:
                    Write((kind << 4) + 15);
                    Write(0x12);
                    WriteBytes(value, 4);

                    break;
            }
        }

        internal void Write(int b)
        {
            outStream.WriteByte((byte)b);
            count++;
        }

        internal void Write(byte[] bytes)
        {
            outStream.Write(bytes, 0, bytes.Length);
            count += bytes.Length;
        }

        internal void Write(Span<byte> bytes)
        {
        #if NATIVE_SPAN
            outStream.Write(bytes);
            count += bytes.Length;
        #else
            Write(bytes.ToArray());
        #endif
        }

        internal void WriteBytes(long value, int bytes)
        {
            // write low-order bytes big-endian style
            for(int i = bytes - 1; i >= 0; i--)
                Write((int)(value >> (8 * i)));
        }

        internal void WriteID(int id) => WriteBytes(id, idSizeInBytes);

        internal void WriteLong(long value) => WriteBytes(value, 8);

        internal void WriteDouble(double value) => WriteLong(BitConverter.DoubleToInt64Bits(value));

        internal static bool IsSerializationPrimitive(NSString obj)
        {
            string content = obj.Content;

            // This is a list of "special" values which are only added once to a binary property
            // list, and can be referenced multiple times.
            return content is "$class" or "$classes" or "$classname" or "NS.objects" or "NS.keys" or "NS.base" or
                       "NS.relative" or "NS.string" or "NSURL" or "NSDictionary" or "NSObject" or "NSMutableDictionary"
                       or "NSMutableArray" or "NSArray" or "NSUUID" or "NSKeyedArchiver" or "NSMutableString";
        }

        internal static bool IsSerializationPrimitive(NSNumber n) => n.isBoolean();
    }
}

// BinaryPropertyListWriter.GetObjectEqualityComparer.cs
namespace Squirrel.Packaging.OSX
{
    internal partial class BinaryPropertyListWriter
    {
        /// <summary>
        ///     The equality comparer which is used when retrieving objects in the
        ///     <see cref="BinaryPropertyListWriter.idMap" />. The logic is slightly different from
        ///     <see cref="AddObjectEqualityComparer" />, results in two equivalent objects (UIDs mainly) being added to the
        ///     <see cref="BinaryPropertyListWriter.idMap" />. Whenever the ID for one of those equivalent objects is requested,
        ///     the first ID is always returned. This means that there are "orphan" objects in binary property lists - duplicate
        ///     objects which are never referenced -; this logic exists purely to maintain binary compatibility with Apple's
        ///     format.
        /// </summary>
        class GetObjectEqualityComparer : EqualityComparer<NSObject>
        {
            public override bool Equals(NSObject x, NSObject y) => x switch
            {
                // By default, use reference equality. Even if there are two objects - say a NSString - with the same
                // value, do not consider them equal unless they are the same instance of NSString.
                // The exceptions are UIDs, where we always compare by value, and "primitive" strings (a list of well-known
                // strings), which are treaded specially and "recycled".
                UID                                                       => x.Equals(y),
                NSNumber number when IsSerializationPrimitive(number)     => number.Equals(y),
                NSString nsString when IsSerializationPrimitive(nsString) => nsString.Equals(y),
                _                                                         => ReferenceEquals(x, y)
            };

            public override int GetHashCode(NSObject obj) => obj switch
            {
                UID u                                       => u.GetHashCode(),
                NSNumber n when IsSerializationPrimitive(n) => n.ToObject().GetHashCode(),
                NSString s when IsSerializationPrimitive(s) => s.Content.GetHashCode(),
                _                                           => obj.GetHashCode()
            };
        }
    }
}

// NSArray.cs
namespace Squirrel.Packaging.OSX
{
    /// <summary>Represents an Array.</summary>
    /// @author Daniel Dreibrodt
    /// @author Natalia Portillo
    internal partial class NSArray : NSObject
    {
        readonly List<NSObject> array;

        /// <summary>Creates an empty array of the given length.</summary>
        /// <param name="length">The number of elements this array will be able to hold.</param>
        public NSArray(int length) => array = new List<NSObject>(length);

        /// <summary>Creates a array from an existing one</summary>
        /// <param name="a">The array which should be wrapped by the NSArray.</param>
        public NSArray(params NSObject[] a) => array = new List<NSObject>(a);

        /// <summary>Returns the size of the array.</summary>
        /// <value>The number of elements that this array can store.</value>
        public int Count => array.Count;

        /// <summary>Returns the object stored at the given index.</summary>
        /// <returns>The object at the given index.</returns>
        /// <param name="i">The index of the object.</param>
        [Obsolete]
        public NSObject ObjectAtIndex(int i) => array[i];

        /// <summary>Remove the i-th element from the array. The array will be resized.</summary>
        /// <param name="i">The index of the object</param>
        [Obsolete]
        public void Remove(int i) => array.RemoveAt(i);

        /// <summary>Stores an object at the specified index. If there was another object stored at that index it will be replaced.</summary>
        /// <param name="key">The index where to store the object.</param>
        /// <param name="value">The object.</param>
        [Obsolete]
        public void SetValue(int key, object value)
        {
            if(value == null)
                throw new ArgumentNullException("value", "Cannot add null values to an NSArray!");

            array[key] = Wrap(value);
        }

        /// <summary>
        ///     Returns the array of NSObjects represented by this NSArray. Any changes to the values of this array will also
        ///     affect the NSArray.
        /// </summary>
        /// <returns>The actual array represented by this NSArray.</returns>
        [Obsolete]
        public NSObject[] GetArray() => array.ToArray();

        /// <summary>Checks whether an object is present in the array or whether it is equal to any of the objects in the array.</summary>
        /// <returns><c>true</c>, when the object could be found. <c>false</c> otherwise.</returns>
        /// <param name="obj">The object to look for.</param>
        [Obsolete]
        public bool ContainsObject(object obj)
        {
            NSObject nso = Wrap(obj);

            foreach(NSObject elem in array)
                if(elem.Equals(nso))
                    return true;

            return false;
        }

        /// <summary>
        ///     Searches for an object in the array. If it is found its index will be returned. This method also returns an
        ///     index if the object is not the same as the one stored in the array but has equal contents.
        /// </summary>
        /// <returns>The index of the object, if it was found. -1 otherwise.</returns>
        /// <param name="obj">The object to look for.</param>
        [Obsolete]
        public int IndexOfObject(object obj)
        {
            NSObject nso = Wrap(obj);

            for(int i = 0; i < array.Count; i++)
                if(array[i].Equals(nso))
                    return i;

            return -1;
        }

        /// <summary>
        ///     Searches for an object in the array. If it is found its index will be returned. This method only returns the
        ///     index of an object that is <b>identical</b> to the given one. Thus objects that might contain the same value as the
        ///     given one will not be considered.
        /// </summary>
        /// <returns>The index of the object, if it was found. -1 otherwise.</returns>
        /// <param name="obj">The object to look for.</param>
        [Obsolete]
        public int IndexOfIdenticalObject(object obj)
        {
            NSObject nso = Wrap(obj);

            for(int i = 0; i < array.Count; i++)
                if(array[i] == nso)
                    return i;

            return -1;
        }

        /// <summary>Returns the last object contained in this array.</summary>
        /// <returns>The value of the highest index in the array.</returns>
        public NSObject LastObject() => array[array.Count - 1];

        /// <summary>
        ///     Returns a new array containing only the values stored at the given indices. The values are sorted by their
        ///     index.
        /// </summary>
        /// <returns>The new array containing the objects stored at the given indices.</returns>
        /// <param name="indexes">The indices of the objects.</param>
        public NSObject[] ObjectsAtIndexes(params int[] indexes)
        {
            NSObject[] result = new NSObject[indexes.Length];
            Array.Sort(indexes);

            for(int i = 0; i < indexes.Length; i++)
                result[i] = array[indexes[i]];

            return result;
        }

        /// <summary>
        ///     Determines whether the specified <see cref="System.Object" /> is equal to the current
        ///     <see cref="Squirrel.PropertyList.NSArray" />.
        /// </summary>
        /// <param name="obj">
        ///     The <see cref="System.Object" /> to compare with the current
        ///     <see cref="Squirrel.PropertyList.NSArray" />.
        /// </param>
        /// <returns>
        ///     <c>true</c> if the specified <see cref="System.Object" /> is equal to the current
        ///     <see cref="Squirrel.PropertyList.NSArray" />; otherwise, <c>false</c>.
        /// </returns>
        public override bool Equals(object obj)
        {
            if(obj is NSArray nsArray)
                return ArrayEquals(nsArray, this);

            NSObject nso = Wrap(obj);

            if(nso is NSArray nsoArray)
                return ArrayEquals(nsoArray, this);

            return false;
        }

        /// <summary>Serves as a hash function for a <see cref="Squirrel.PropertyList.NSArray" /> object.</summary>
        /// <returns>
        ///     A hash code for this instance that is suitable for use in hashing algorithms and data structures such as a
        ///     hash table.
        /// </returns>
        public override int GetHashCode()
        {
            int hash = 7;
            hash = (89 * hash) + array.GetHashCode();

            return hash;
        }

        internal override void ToXml(StringBuilder xml, int level)
        {
            Indent(xml, level);
            xml.Append("<array>");
            xml.Append(NEWLINE);

            foreach(NSObject o in array)
            {
                o.ToXml(xml, level + 1);
                xml.Append(NEWLINE);
            }

            Indent(xml, level);
            xml.Append("</array>");
        }

        internal override void AssignIDs(BinaryPropertyListWriter outPlist)
        {
            base.AssignIDs(outPlist);

            foreach(NSObject obj in array)
                obj.AssignIDs(outPlist);
        }

        internal override void ToBinary(BinaryPropertyListWriter outPlist)
        {
            outPlist.WriteIntHeader(0xA, array.Count);

            foreach(NSObject obj in array)
                outPlist.WriteID(outPlist.GetID(obj));
        }

        /// <summary>
        ///     <para>Generates a valid ASCII property list which has this NSArray as its root object.</para>
        ///     <para>
        ///         The generated property list complies with the format as described in
        ///         https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/PropertyLists/OldStylePlists/OldStylePLists.html
        ///         Property List Programming Guide - Old-Style ASCII Property Lists.
        ///     </para>
        /// </summary>
        /// <returns>ASCII representation of this object.</returns>
        public string ToASCIIPropertyList()
        {
            var ascii = new StringBuilder();
            ToASCII(ascii, 0);
            ascii.Append(NEWLINE);

            return ascii.ToString();
        }

        /// <summary>
        ///     <para>Generates a valid ASCII property list in GnuStep format which has this NSArray as its root object.</para>
        ///     <para>
        ///         The generated property list complies with the format as described in
        ///         http://www.gnustep.org/resources/documentation/Developer/Base/Reference/NSPropertyList.html GnuStep -
        ///         NSPropertyListSerialization class documentation.
        ///     </para>
        /// </summary>
        /// <returns>GnuStep ASCII representation of this object.</returns>
        public string ToGnuStepASCIIPropertyList()
        {
            var ascii = new StringBuilder();
            ToASCIIGnuStep(ascii, 0);
            ascii.Append(NEWLINE);

            return ascii.ToString();
        }

        internal override void ToASCII(StringBuilder ascii, int level)
        {
            Indent(ascii, level);
            ascii.Append(ASCIIPropertyListParser.ARRAY_BEGIN_TOKEN);
            int indexOfLastNewLine = ascii.ToString().LastIndexOf(NEWLINE, StringComparison.Ordinal);

            for(int i = 0; i < array.Count; i++)
            {
                if((array[i] is NSDictionary || array[i] is NSArray || array[i] is NSData) &&
                   indexOfLastNewLine != ascii.Length)
                {
                    ascii.Append(NEWLINE);
                    indexOfLastNewLine = ascii.Length;
                    array[i].ToASCII(ascii, level + 1);
                }
                else
                {
                    if(i != 0)
                        ascii.Append(" ");

                    array[i].ToASCII(ascii, 0);
                }

                if(i != array.Count - 1)
                    ascii.Append(ASCIIPropertyListParser.ARRAY_ITEM_DELIMITER_TOKEN);

                if(ascii.Length - indexOfLastNewLine <= ASCII_LINE_LENGTH)
                    continue;

                ascii.Append(NEWLINE);
                indexOfLastNewLine = ascii.Length;
            }

            ascii.Append(ASCIIPropertyListParser.ARRAY_END_TOKEN);
        }

        internal override void ToASCIIGnuStep(StringBuilder ascii, int level)
        {
            Indent(ascii, level);
            ascii.Append(ASCIIPropertyListParser.ARRAY_BEGIN_TOKEN);
            int indexOfLastNewLine = ascii.ToString().LastIndexOf(NEWLINE, StringComparison.Ordinal);

            for(int i = 0; i < array.Count; i++)
            {
                Type objClass = array[i].GetType();

                if((array[i] is NSDictionary || array[i] is NSArray || array[i] is NSData) &&
                   indexOfLastNewLine != ascii.Length)
                {
                    ascii.Append(NEWLINE);
                    indexOfLastNewLine = ascii.Length;
                    array[i].ToASCIIGnuStep(ascii, level + 1);
                }
                else
                {
                    if(i != 0)
                        ascii.Append(" ");

                    array[i].ToASCIIGnuStep(ascii, 0);
                }

                if(i != array.Count - 1)
                    ascii.Append(ASCIIPropertyListParser.ARRAY_ITEM_DELIMITER_TOKEN);

                if(ascii.Length - indexOfLastNewLine <= ASCII_LINE_LENGTH)
                    continue;

                ascii.Append(NEWLINE);
                indexOfLastNewLine = ascii.Length;
            }

            ascii.Append(ASCIIPropertyListParser.ARRAY_END_TOKEN);
        }

        /// <summary>
        ///     Determines whether the specified <see cref="Squirrel.PropertyList.NSObject" /> is equal to the current
        ///     <see cref="Squirrel.PropertyList.NSArray" />.
        /// </summary>
        /// <param name="obj">
        ///     The <see cref="Squirrel.PropertyList.NSObject" /> to compare with the current
        ///     <see cref="Squirrel.PropertyList.NSArray" />.
        /// </param>
        /// <returns>
        ///     <c>true</c> if the specified <see cref="Squirrel.PropertyList.NSObject" /> is equal to the current
        ///     <see cref="Squirrel.PropertyList.NSArray" />; otherwise, <c>false</c>.
        /// </returns>
        public override bool Equals(NSObject obj)
        {
            if(obj is not NSArray nsArray)
                return false;

            if(array.Count != nsArray.array.Count)
                return false;

            for(int i = 0; i < array.Count; i++)
                if(!array[i].Equals(nsArray[i]))
                    return false;

            return true;
        }
    }
}

// NSArray.IList.cs
namespace Squirrel.Packaging.OSX
{
    partial class NSArray : IList<NSObject>
    {
        /// <inheritdoc />
        public NSObject this[int index]
        {
            get => array[index];

            set => array[index] = value;
        }

        /// <inheritdoc />
        public bool IsReadOnly => false;

        /// <inheritdoc />
        public void Add(NSObject item) => array.Add(item);

        /// <inheritdoc />
        public void Clear() => array.Clear();

        /// <inheritdoc />
        public bool Contains(NSObject item) => array.Contains(item);

        /// <inheritdoc />
        public void CopyTo(NSObject[] array, int arrayIndex) => this.array.CopyTo(array, arrayIndex);

        /// <inheritdoc />
        public IEnumerator<NSObject> GetEnumerator() => array.GetEnumerator();

        /// <inheritdoc />
        public int IndexOf(NSObject item) => array.IndexOf(item);

        /// <inheritdoc />
        public void Insert(int index, NSObject item) => array.Insert(index, item);

        /// <inheritdoc />
        public bool Remove(NSObject item) => array.Remove(item);

        /// <inheritdoc />
        public void RemoveAt(int index) => array.RemoveAt(index);

        /// <inheritdoc />
        IEnumerator IEnumerable.GetEnumerator() => array.GetEnumerator();

        public void Add(object item) => Add(Wrap(item));

        public bool Contains(object item) => Contains(Wrap(item));

        public int IndexOf(object item) => array.IndexOf(Wrap(item));

        public void Insert(int index, object item) => Insert(index, Wrap(item));

        public bool Remove(object item) => Remove(Wrap(item));
    }
}

// NSData.cs
namespace Squirrel.Packaging.OSX
{
    /// <summary>NSData objects are wrappers for byte buffers</summary>
    /// @author Daniel Dreibrodt
    /// @author Natalia Portillo
    internal class NSData : NSObject
    {
        // In the XML property list format, the base-64 encoded data is split across multiple lines.
        // Each line contains 68 characters.
        const int DataLineLength = 68;

        /// <summary>Creates the NSData object from the binary representation of it.</summary>
        /// <param name="bytes">The raw data contained in the NSData object.</param>
        public NSData(byte[] bytes) => Bytes = bytes;

        /// <summary>Creates a NSData object from its textual representation, which is a Base64 encoded amount of bytes.</summary>
        /// <param name="base64">The Base64 encoded contents of the NSData object.</param>
        /// <exception cref="FormatException">When the given string is not a proper Base64 formatted string.</exception>
        public NSData(string base64) => Bytes = Convert.FromBase64String(base64);

        /// <summary>Creates a NSData object from a file. Using the files contents as the contents of this NSData object.</summary>
        /// <param name="file">The file containing the data.</param>
        /// <exception cref="FileNotFoundException">If the file could not be found.</exception>
        /// <exception cref="IOException">If the file could not be read.</exception>
        public NSData(FileInfo file)
        {
            Bytes = new byte[(int)file.Length];

            using FileStream raf = file.OpenRead();

            raf.Read(Bytes, 0, (int)file.Length);
        }

        /// <summary>The bytes contained in this NSData object.</summary>
        /// <value>The data as bytes</value>
        public byte[] Bytes { get; }

        /// <summary>Gets the amount of data stored in this object.</summary>
        /// <value>The number of bytes contained in this object.</value>
        public int Length => Bytes.Length;

        /// <summary>Loads the bytes from this NSData object into a byte buffer.</summary>
        /// <param name="buf">The byte buffer which will contain the data</param>
        /// <param name="length">The amount of data to copy</param>
        public void GetBytes(MemoryStream buf, int length) => buf.Write(Bytes, 0, Math.Min(Bytes.Length, length));

        /// <summary>Loads the bytes from this NSData object into a byte buffer.</summary>
        /// <param name="buf">The byte buffer which will contain the data</param>
        /// <param name="rangeStart">The start index.</param>
        /// <param name="rangeStop">The stop index.</param>
        public void GetBytes(MemoryStream buf, int rangeStart, int rangeStop) =>
            buf.Write(Bytes, rangeStart, Math.Min(Bytes.Length, rangeStop));

        /// <summary>Gets the Base64 encoded data contained in this NSData object.</summary>
        /// <returns>The Base64 encoded data as a <c>string</c>.</returns>
        public string GetBase64EncodedData() => Convert.ToBase64String(Bytes);

        /// <summary>
        ///     Determines whether the specified <see cref="System.Object" /> is equal to the current
        ///     <see cref="Squirrel.PropertyList.NSData" />.
        /// </summary>
        /// <param name="obj">
        ///     The <see cref="System.Object" /> to compare with the current
        ///     <see cref="Squirrel.PropertyList.NSData" />.
        /// </param>
        /// <returns>
        ///     <c>true</c> if the specified <see cref="System.Object" /> is equal to the current
        ///     <see cref="Squirrel.PropertyList.NSData" />; otherwise, <c>false</c>.
        /// </returns>
        public override bool Equals(object obj) =>
            obj.GetType().Equals(GetType()) && ArrayEquals(((NSData)obj).Bytes, Bytes);

        /// <summary>Serves as a hash function for a <see cref="Squirrel.PropertyList.NSData" /> object.</summary>
        /// <returns>
        ///     A hash code for this instance that is suitable for use in hashing algorithms and data structures such as a
        ///     hash table.
        /// </returns>
        public override int GetHashCode()
        {
            int hash = 5;
            hash = (67 * hash) + Bytes.GetHashCode();

            return hash;
        }

        internal override void ToXml(StringBuilder xml, int level)
        {
            Indent(xml, level);
            xml.Append("<data>");
            xml.Append(NEWLINE);
            string base64 = GetBase64EncodedData();

            foreach(string line in base64.Split('\n'))
                for(int offset = 0; offset < base64.Length; offset += DataLineLength)
                {
                    Indent(xml, level);
                    xml.Append(line.Substring(offset, Math.Min(DataLineLength, line.Length - offset)));
                    xml.Append(NEWLINE);
                }

            Indent(xml, level);
            xml.Append("</data>");
        }

        internal override void ToBinary(BinaryPropertyListWriter outPlist)
        {
            outPlist.WriteIntHeader(0x4, Bytes.Length);
            outPlist.Write(Bytes);
        }

        internal override void ToASCII(StringBuilder ascii, int level)
        {
            Indent(ascii, level);
            ascii.Append(ASCIIPropertyListParser.DATA_BEGIN_TOKEN);
            int indexOfLastNewLine = ascii.ToString().LastIndexOf(NEWLINE, StringComparison.Ordinal);

            for(int i = 0; i < Bytes.Length; i++)
            {
                int b = Bytes[i] & 0xFF;
                ascii.Append($"{b:x2}");

                if(ascii.Length - indexOfLastNewLine > ASCII_LINE_LENGTH)
                {
                    ascii.Append(NEWLINE);
                    indexOfLastNewLine = ascii.Length;
                }
                else if((i + 1) % 2 == 0 &&
                        i           != Bytes.Length - 1)
                    ascii.Append(" ");
            }

            ascii.Append(ASCIIPropertyListParser.DATA_END_TOKEN);
        }

        internal override void ToASCIIGnuStep(StringBuilder ascii, int level) => ToASCII(ascii, level);

        /// <summary>
        ///     Determines whether the specified <see cref="Squirrel.PropertyList.NSObject" /> is equal to the current
        ///     <see cref="Squirrel.PropertyList.NSData" />.
        /// </summary>
        /// <param name="obj">
        ///     The <see cref="Squirrel.PropertyList.NSObject" /> to compare with the current
        ///     <see cref="Squirrel.PropertyList.NSData" />.
        /// </param>
        /// <returns>
        ///     <c>true</c> if the specified <see cref="Squirrel.PropertyList.NSObject" /> is equal to the current
        ///     <see cref="Squirrel.PropertyList.NSData" />; otherwise, <c>false</c>.
        /// </returns>
        public override bool Equals(NSObject obj) => obj is NSData data && ArrayEquals(Bytes, data.Bytes);

        public static explicit operator byte[](NSData value) => value.Bytes;

        public static explicit operator NSData(byte[] value) => new(value);
    }
}

// NSDate.cs
namespace Squirrel.Packaging.OSX
{
    /// <summary>Represents a date</summary>
    /// @author Daniel Dreibrodt
    /// @author Natalia Portillo
    internal class NSDate : NSObject
    {
        static readonly DateTime EPOCH = new(2001, 1, 1, 0, 0, 0, DateTimeKind.Utc);

        // The datetime ends with 'Z', which indicates UTC time. To make sure .NET
        // understands the 'Z' character as a timezone, specify the 'K' format string.
        static readonly string sdfDefault = "yyyy-MM-dd'T'HH:mm:ssK";
        static readonly string sdfGnuStep = "yyyy-MM-dd HH:mm:ss zzz";
        static readonly string[] sdfAll =
        {
            sdfDefault, sdfGnuStep
        };

        static readonly CultureInfo provider = CultureInfo.InvariantCulture;

        /// <summary>Creates a date from its binary representation.</summary>
        /// <param name="bytes">bytes The date bytes</param>
        public NSDate(ReadOnlySpan<byte> bytes) =>

            //dates are 8 byte big-endian double, seconds since the epoch
            Date = EPOCH.AddSeconds(BinaryPropertyListParser.ParseDouble(bytes));

        /// <summary>
        ///     Parses a date from its textual representation. That representation has the following pattern:
        ///     <code>yyyy-MM-dd'T'HH:mm:ss'Z'</code>
        /// </summary>
        /// <param name="textRepresentation">The textual representation of the date (ISO 8601 format)</param>
        /// <exception cref="FormatException">When the date could not be parsed, i.e. it does not match the expected pattern.</exception>
        public NSDate(string textRepresentation) => Date = ParseDateString(textRepresentation);

        /// <summary>Creates a NSDate from a .NET DateTime</summary>
        /// <param name="d">The date</param>
        public NSDate(DateTime d) => Date = d;

        /// <summary>Gets the date.</summary>
        /// <returns>The date.</returns>
        public DateTime Date { get; }

        /// <summary>Parses the XML date string and creates a .NET DateTime object from it.</summary>
        /// <returns>The parsed Date</returns>
        /// <param name="textRepresentation">The date string as found in the XML property list</param>
        /// <exception cref="FormatException">Given string cannot be parsed</exception>
        static DateTime ParseDateString(string textRepresentation) =>
            DateTime.ParseExact(textRepresentation, sdfAll, provider, DateTimeStyles.None);

        /// <summary>
        ///     Generates a String representation of a .NET DateTime object. The string is formatted according to the
        ///     specification for XML property list dates.
        /// </summary>
        /// <param name="date">The date which should be represented.</param>
        /// <returns>The string representation of the date.</returns>
        public static string MakeDateString(DateTime date) => date.ToUniversalTime().ToString(sdfDefault, provider);

        /// <summary>
        ///     Generates a String representation of a .NET DateTime object. The string is formatted according to the
        ///     specification for GnuStep ASCII property list dates.
        /// </summary>
        /// <param name="date">The date which should be represented.</param>
        /// <returns>The string representation of the date.</returns>
        static string MakeDateStringGnuStep(DateTime date) => date.ToString(sdfGnuStep, provider);

        /// <summary>
        ///     Determines whether the specified <see cref="System.Object" /> is equal to the current
        ///     <see cref="Squirrel.PropertyList.NSDate" />.
        /// </summary>
        /// <param name="obj">
        ///     The <see cref="System.Object" /> to compare with the current
        ///     <see cref="Squirrel.PropertyList.NSDate" />.
        /// </param>
        /// <returns>
        ///     <c>true</c> if the specified <see cref="System.Object" /> is equal to the current
        ///     <see cref="Squirrel.PropertyList.NSDate" />; otherwise, <c>false</c>.
        /// </returns>
        public override bool Equals(object obj) => obj.GetType().Equals(GetType()) && Date.Equals(((NSDate)obj).Date);

        /// <summary>Serves as a hash function for a <see cref="Squirrel.PropertyList.NSDate" /> object.</summary>
        /// <returns>
        ///     A hash code for this instance that is suitable for use in hashing algorithms and data structures such as a
        ///     hash table.
        /// </returns>
        public override int GetHashCode() => Date.GetHashCode();

        internal override void ToXml(StringBuilder xml, int level)
        {
            Indent(xml, level);
            xml.Append("<date>");
            xml.Append(MakeDateString(Date));
            xml.Append("</date>");
        }

        internal override void ToBinary(BinaryPropertyListWriter outPlist)
        {
            outPlist.Write(0x33);
            outPlist.WriteDouble((Date - EPOCH).TotalSeconds);
        }

        /// <summary>Generates a string representation of the date.</summary>
        /// <returns>A string representation of the date.</returns>
        public override string ToString() => Date.ToString();

        internal override void ToASCII(StringBuilder ascii, int level)
        {
            Indent(ascii, level);
            ascii.Append("\"");
            ascii.Append(MakeDateString(Date));
            ascii.Append("\"");
        }

        internal override void ToASCIIGnuStep(StringBuilder ascii, int level)
        {
            Indent(ascii, level);
            ascii.Append("<*D");
            ascii.Append(MakeDateStringGnuStep(Date));
            ascii.Append(">");
        }

        /// <summary>
        ///     Determines whether the specified <see cref="Squirrel.PropertyList.NSObject" /> is equal to the current
        ///     <see cref="Squirrel.PropertyList.NSDate" />.
        /// </summary>
        /// <param name="obj">
        ///     The <see cref="Squirrel.PropertyList.NSObject" /> to compare with the current
        ///     <see cref="Squirrel.PropertyList.NSDate" />.
        /// </param>
        /// <returns>
        ///     <c>true</c> if the specified <see cref="Squirrel.PropertyList.NSObject" /> is equal to the current
        ///     <see cref="Squirrel.PropertyList.NSDate" />; otherwise, <c>false</c>.
        /// </returns>
        public override bool Equals(NSObject obj)
        {
            if(obj is not NSDate date)
                return false;

            int equality = DateTime.Compare(Date, date.Date);

            return equality == 0;
        }

        public static explicit operator DateTime(NSDate value) => value.Date;

        public static explicit operator NSDate(DateTime value) => new(value);
    }
}

// NSDictionary.cs
namespace Squirrel.Packaging.OSX
{
    /// <summary>
    ///     <para>
    ///         A NSDictionary is a collection of keys and values, essentially a Dictionary. The keys are simple Strings
    ///         whereas the values can be any kind of NSObject.
    ///     </para>
    ///     <para>You can access the keys through the function <see cref="Keys" />.</para>
    ///     <para>Access to the objects stored for each key is given through the function <see cref="ObjectForKey" />.</para>
    /// </summary>
    /// @author Daniel Dreibrodt
    /// @author Natalia Portillo
    internal class NSDictionary : NSObject, IDictionary<string, NSObject>
    {
        readonly Dictionary<string, NSObject> dict;

        // Maps the keys in this dictionary to their NSString equivalent. Makes sure the NSString
        // object remains constant across calls to AssignIDs and ToBinary
        readonly Dictionary<string, NSString> keys;

        /// <summary>Creates a new empty NSDictionary with a specific capacity.</summary>
        /// <param name="capacity">The capacity of the dictionary.</param>
        public NSDictionary(int capacity)
        {
            dict = new Dictionary<string, NSObject>(capacity);
            keys = new Dictionary<string, NSString>(capacity);
        }

        /// <summary>Creates a new empty NSDictionary.</summary>
        public NSDictionary() : this(0) {}

        /// <summary>Gets a value indicating whether this instance is empty.</summary>
        /// <value><c>true</c> if this instance is empty; otherwise, <c>false</c>.</value>
        public bool IsEmpty => dict.Count == 0;

        #region IEnumerable implementation
        /// <summary>Gets the enumerator.</summary>
        /// <returns>The enumerator.</returns>
        public IEnumerator<KeyValuePair<string, NSObject>> GetEnumerator() => dict.GetEnumerator();
        #endregion

        #region IEnumerable implementation
        IEnumerator IEnumerable.GetEnumerator() => dict.GetEnumerator();
        #endregion

        /// <summary>
        ///     Gets the hashmap which stores the keys and values of this dictionary. Changes to the hashmap's contents are
        ///     directly reflected in this dictionary.
        /// </summary>
        /// <returns>The hashmap which is used by this dictionary to store its contents.</returns>
        public Dictionary<string, NSObject> GetDictionary() => dict;

        /// <summary>Gets the NSObject stored for the given key.</summary>
        /// <returns>The object.</returns>
        /// <param name="key">The key.</param>
        public NSObject ObjectForKey(string key)
        {
            NSObject nso;

            return dict.TryGetValue(key, out nso) ? nso : null;
        }

        /// <summary>Checks if the specified object key is contained in the current instance.</summary>
        /// <returns><c>true</c>, if key is contained, <c>false</c> otherwise.</returns>
        /// <param name="key">Key.</param>
        public bool ContainsKey(object key) => key is string s && dict.ContainsKey(s);

        /// <summary>Removes the item corresponding to the specified key from the current instance, if found.</summary>
        /// <param name="key">Key.</param>
        /// <returns><c>true</c>, if  removed, <c>false</c> otherwise.</returns>
        public bool Remove(object key) => key is string s && dict.Remove(s);

        /// <summary>Gets the <see cref="NSObject" /> corresponding to the specified key from the current instance.</summary>
        /// <param name="key">Key.</param>
        /// <returns>The object corresponding to the specified key, null if not found in the current instance.</returns>
        public NSObject Get(object key)
        {
            if(key is string s)
                return ObjectForKey(s);

            return null;
        }

        /// <summary>Checks if the current instance contains the object corresponding to the specified key.</summary>
        /// <returns><c>true</c>, if value is contained, <c>false</c> otherwise.</returns>
        /// <param name="value">Object to search up in the current instance.</param>
        public bool ContainsValue(object value)
        {
            if(value == null)
                return false;

            NSObject wrap = Wrap(value);

            return dict.ContainsValue(wrap);
        }

        /// <summary>
        ///     Puts a new key-value pair into this dictionary. If the value is null, no operation will be performed on the
        ///     dictionary.
        /// </summary>
        /// <param name="key">The key.</param>
        /// <param name="obj">
        ///     The value. Supported object types are numbers, byte-arrays, dates, strings and arrays or sets of
        ///     those.
        /// </param>
        public void Add(string key, object obj)
        {
            if(obj == null)
                return;

            Add(key, Wrap(obj));
        }

        /// <summary>Puts a new key-value pair into this dictionary.</summary>
        /// <param name="key">The key.</param>
        /// <param name="obj">The value.</param>
        public void Add(string key, long obj) => Add(key, new NSNumber(obj));

        /// <summary>Puts a new key-value pair into this dictionary.</summary>
        /// <param name="key">The key.</param>
        /// <param name="obj">The value.</param>
        public void Add(string key, double obj) => Add(key, new NSNumber(obj));

        /// <summary>Puts a new key-value pair into this dictionary.</summary>
        /// <param name="key">The key.</param>
        /// <param name="obj">The value.</param>
        public void Add(string key, bool obj) => Add(key, new NSNumber(obj));

        /// <summary>Checks whether a given value is contained in this dictionary.</summary>
        /// <param name="val">The value that will be searched for.</param>
        /// <returns>Whether the key is contained in this dictionary.</returns>
        public bool ContainsValue(string val)
        {
            foreach(NSObject o in dict.Values)
                if(o is NSString str &&
                   str.Content.Equals(val))
                    return true;

            return false;
        }

        /// <summary>Checks whether a given value is contained in this dictionary.</summary>
        /// <param name="val">The value that will be searched for.</param>
        /// <returns>Whether the key is contained in this dictionary.</returns>
        public bool ContainsValue(long val)
        {
            foreach(NSObject o in dict.Values)
                if(o is NSNumber num &&
                   num.isInteger()   &&
                   num.ToInt() == val)
                    return true;

            return false;
        }

        /// <summary>Checks whether a given value is contained in this dictionary.</summary>
        /// <param name="val">The value that will be searched for.</param>
        /// <returns>Whether the key is contained in this dictionary.</returns>
        public bool ContainsValue(double val)
        {
            foreach(NSObject o in dict.Values)
                if(o is NSNumber num &&
                   num.isReal()      &&
                   num.ToDouble() == val)
                    return true;

            return false;
        }

        /// <summary>Checks whether a given value is contained in this dictionary.</summary>
        /// <param name="val">The value that will be searched for.</param>
        /// <returns>Whether the key is contained in this dictionary.</returns>
        public bool ContainsValue(bool val)
        {
            foreach(NSObject o in dict.Values)
                if(o is NSNumber num &&
                   num.isBoolean()   &&
                   num.ToBool() == val)
                    return true;

            return false;
        }

        /// <summary>Checks whether a given value is contained in this dictionary.</summary>
        /// <param name="val">The value that will be searched for.</param>
        /// <returns>Whether the key is contained in this dictionary.</returns>
        public bool ContainsValue(DateTime val)
        {
            foreach(NSObject o in dict.Values)
                if(o is NSDate dat &&
                   dat.Date.Equals(val))
                    return true;

            return false;
        }

        /// <summary>Checks whether a given value is contained in this dictionary.</summary>
        /// <param name="val">The value that will be searched for.</param>
        /// <returns>Whether the key is contained in this dictionary.</returns>
        public bool ContainsValue(byte[] val)
        {
            foreach(NSObject o in dict.Values)
                if(o is NSData dat &&
                   ArrayEquals(dat.Bytes, val))
                    return true;

            return false;
        }

        /// <summary>
        ///     Determines whether the specified <see cref="Squirrel.PropertyList.NSObject" /> is equal to the current
        ///     <see cref="Squirrel.PropertyList.NSDictionary" />.
        /// </summary>
        /// <param name="obj">
        ///     The <see cref="Squirrel.PropertyList.NSObject" /> to compare with the current
        ///     <see cref="Squirrel.PropertyList.NSDictionary" />.
        /// </param>
        /// <returns>
        ///     <c>true</c> if the specified <see cref="Squirrel.PropertyList.NSObject" /> is equal to the current
        ///     <see cref="Squirrel.PropertyList.NSDictionary" />; otherwise, <c>false</c>.
        /// </returns>
        public override bool Equals(NSObject obj)
        {
            if(obj is not NSDictionary dictionary)
                return false;

            if(dictionary.dict.Count != dict.Count)
                return false;

            foreach(KeyValuePair<string, NSObject> kvp in dict)
            {
                bool found = dictionary.dict.TryGetValue(kvp.Key, out NSObject nsoB);

                if(!found)
                    return false;

                if(!kvp.Value.Equals(nsoB))
                    return false;
            }

            return true;
        }

        /// <summary>Serves as a hash function for a <see cref="Squirrel.PropertyList.NSDictionary" /> object.</summary>
        /// <returns>
        ///     A hash code for this instance that is suitable for use in hashing algorithms and data structures such as a
        ///     hash table.
        /// </returns>
        public override int GetHashCode()
        {
            int hash = 7;
            hash = (83 * hash) + (dict != null ? dict.GetHashCode() : 0);

            return hash;
        }

        internal override void ToXml(StringBuilder xml, int level)
        {
            Indent(xml, level);
            xml.Append("<dict>");
            xml.Append(NEWLINE);

            foreach(KeyValuePair<string, NSObject> kvp in dict)
            {
                Indent(xml, level + 1);
                xml.Append("<key>");

                //According to http://www.w3.org/TR/REC-xml/#syntax node values must not
                //contain the characters < or &. Also the > character should be escaped.
                if(kvp.Key.Contains("&") ||
                   kvp.Key.Contains("<") ||
                   kvp.Key.Contains(">"))
                {
                    xml.Append("<![CDATA[");
                    xml.Append(kvp.Key.Replace("]]>", "]]]]><![CDATA[>"));
                    xml.Append("]]>");
                }
                else
                    xml.Append(kvp.Key);

                xml.Append("</key>");
                xml.Append(NEWLINE);
                kvp.Value.ToXml(xml, level + 1);
                xml.Append(NEWLINE);
            }

            Indent(xml, level);
            xml.Append("</dict>");
        }

        internal override void AssignIDs(BinaryPropertyListWriter outPlist)
        {
            base.AssignIDs(outPlist);

            foreach(KeyValuePair<string, NSObject> entry in dict)
                keys[entry.Key].AssignIDs(outPlist);

            foreach(KeyValuePair<string, NSObject> entry in dict)
                entry.Value.AssignIDs(outPlist);
        }

        internal override void ToBinary(BinaryPropertyListWriter outPlist)
        {
            outPlist.WriteIntHeader(0xD, dict.Count);

            foreach(KeyValuePair<string, NSObject> entry in dict)
                outPlist.WriteID(outPlist.GetID(keys[entry.Key]));

            foreach(KeyValuePair<string, NSObject> entry in dict)
                outPlist.WriteID(outPlist.GetID(entry.Value));
        }

        /// <summary>
        ///     Generates a valid ASCII property list which has this NSDictionary as its root object. The generated property
        ///     list complies with the format as described in
        ///     https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/PropertyLists/OldStylePlists/OldStylePLists.html
        ///     Property List Programming Guide - Old-Style ASCII Property Lists.
        /// </summary>
        /// <returns>ASCII representation of this object.</returns>
        public string ToASCIIPropertyList()
        {
            var ascii = new StringBuilder();
            ToASCII(ascii, 0);
            ascii.Append(NEWLINE);

            return ascii.ToString();
        }

        /// <summary>
        ///     Generates a valid ASCII property list in GnuStep format which has this NSDictionary as its root object. The
        ///     generated property list complies with the format as described in
        ///     http://www.gnustep.org/resources/documentation/Developer/Base/Reference/NSPropertyList.html GnuStep -
        ///     NSPropertyListSerialization class documentation.
        /// </summary>
        /// <returns>GnuStep ASCII representation of this object.</returns>
        public string ToGnuStepASCIIPropertyList()
        {
            var ascii = new StringBuilder();
            ToASCIIGnuStep(ascii, 0);
            ascii.Append(NEWLINE);

            return ascii.ToString();
        }

        internal override void ToASCII(StringBuilder ascii, int level)
        {
            Indent(ascii, level);
            ascii.Append(ASCIIPropertyListParser.DICTIONARY_BEGIN_TOKEN);
            ascii.Append(NEWLINE);

            foreach(string key in Keys)
            {
                NSObject val = ObjectForKey(key);
                Indent(ascii, level + 1);
                ascii.Append("\"");
                ascii.Append(NSString.EscapeStringForASCII(key));
                ascii.Append("\" =");

                if(val is NSDictionary or NSArray or NSData)
                {
                    ascii.Append(NEWLINE);
                    val.ToASCII(ascii, level + 2);
                }
                else
                {
                    ascii.Append(" ");
                    val.ToASCII(ascii, 0);
                }

                ascii.Append(ASCIIPropertyListParser.DICTIONARY_ITEM_DELIMITER_TOKEN);
                ascii.Append(NEWLINE);
            }

            Indent(ascii, level);
            ascii.Append(ASCIIPropertyListParser.DICTIONARY_END_TOKEN);
        }

        internal override void ToASCIIGnuStep(StringBuilder ascii, int level)
        {
            Indent(ascii, level);
            ascii.Append(ASCIIPropertyListParser.DICTIONARY_BEGIN_TOKEN);
            ascii.Append(NEWLINE);

            foreach(string key in Keys)
            {
                NSObject val = ObjectForKey(key);
                Indent(ascii, level + 1);
                ascii.Append("\"");
                ascii.Append(NSString.EscapeStringForASCII(key));
                ascii.Append("\" =");

                if(val is NSDictionary or NSArray or NSData)
                {
                    ascii.Append(NEWLINE);
                    val.ToASCIIGnuStep(ascii, level + 2);
                }
                else
                {
                    ascii.Append(" ");
                    val.ToASCIIGnuStep(ascii, 0);
                }

                ascii.Append(ASCIIPropertyListParser.DICTIONARY_ITEM_DELIMITER_TOKEN);
                ascii.Append(NEWLINE);
            }

            Indent(ascii, level);
            ascii.Append(ASCIIPropertyListParser.DICTIONARY_END_TOKEN);
        }

        #region IDictionary implementation
        /// <summary>Add the specified key and value.</summary>
        /// <param name="key">Key.</param>
        /// <param name="value">Value.</param>
        public void Add(string key, NSObject value)
        {
            dict.Add(key, value);
            keys.Add(key, new NSString(key));
        }

        /// <summary>Checks if there is any item contained in the current instance corresponding with the specified key.</summary>
        /// <returns><c>true</c>, if key was contained, <c>false</c> otherwise.</returns>
        /// <param name="key">Key.</param>
        public bool ContainsKey(string key) => dict.ContainsKey(key);

        /// <summary>Checks if there is any item contained in the current instance corresponding with the specified value.</summary>
        /// <returns><c>true</c>, if value is contained, <c>false</c> otherwise.</returns>
        /// <param name="value">Key.</param>
        public bool ContainsValue(NSObject value) => dict.ContainsValue(value);

        /// <summary>Removes the item belonging to the specified key.</summary>
        /// <param name="key">Key.</param>
        public bool Remove(string key)
        {
            keys.Remove(key);

            return dict.Remove(key);
        }

        /// <summary>Tries to get the item corresponding to the specified key</summary>
        /// <returns><c>true</c>, if get value was successfully found and retrieved, <c>false</c> otherwise.</returns>
        /// <param name="key">Key.</param>
        /// <param name="value">Where to store the value.</param>
        public bool TryGetValue(string key, out NSObject value) => dict.TryGetValue(key, out value);

        /// <summary>Gets or sets the <see cref="Squirrel.PropertyList.NSObject" /> at the specified index.</summary>
        /// <param name="index">Index.</param>
        public NSObject this[string index]
        {
            get => dict[index];
            set
            {
                if(!keys.ContainsKey(index))
                    keys.Add(index, new NSString(index));

                dict[index] = value;
            }
        }

        /// <summary>Gets an array with all the keys contained in the current instance.</summary>
        /// <value>The keys.</value>
        public ICollection<string> Keys => dict.Keys;

        /// <summary>Gets an array with all the objects contained in the current instance.</summary>
        /// <value>The objects.</value>
        public ICollection<NSObject> Values => dict.Values;
        #endregion

        #region ICollection implementation
        /// <summary>Adds the specified item.</summary>
        /// <param name="item">Item.</param>
        public void Add(KeyValuePair<string, NSObject> item)
        {
            keys.Add(item.Key, new NSString(item.Key));
            dict.Add(item.Key, item.Value);
        }

        /// <summary>Clears this instance.</summary>
        public void Clear()
        {
            keys.Clear();
            dict.Clear();
        }

        /// <summary>Checks if the current instance contains the specified item.</summary>
        /// <param name="item">Item.</param>
        /// <returns><c>true</c> if it is found, <c>false</c> otherwise.</returns>
        public bool Contains(KeyValuePair<string, NSObject> item) => dict.ContainsKey(item.Key);

        /// <summary>
        ///     Copies the <see cref="Dictionary{TKey, TValue}.ValueCollection" /> elements to an existing one-dimensional
        ///     <see cref="Array" />, starting at the specified array index.
        /// </summary>
        /// <param name="array">
        ///     The one-dimensional <see cref="Array" /> that is the destination of the elements copied from
        ///     <see cref="Dictionary{TKey, TValue}.ValueCollection" />. The <see cref="Array" /> must have zero-based indexing.
        /// </param>
        /// <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
        public void CopyTo(KeyValuePair<string, NSObject>[] array, int arrayIndex)
        {
            ICollection<KeyValuePair<string, NSObject>> coll = dict;
            coll.CopyTo(array, arrayIndex);
        }

        /// <summary>Removes the specified item.</summary>
        /// <param name="item">Item to remove.</param>
        /// <returns><c>true</c> if successfully removed, <c>false</c> if not, or if item is not in current instance.</returns>
        public bool Remove(KeyValuePair<string, NSObject> item)
        {
            keys.Remove(item.Key);

            return dict.Remove(item.Key);
        }

        /// <summary>Gets the count of items in the current instance.</summary>
        /// <value>How many items are contained in the current instance.</value>
        public int Count => dict.Count;

        /// <summary>Gets a value indicating whether this instance is read only.</summary>
        /// <value><c>true</c> if this instance is read only; otherwise, <c>false</c>.</value>
        public bool IsReadOnly => false;
        #endregion
    }
}

// NSNumber.cs
namespace Squirrel.Packaging.OSX
{
    /// <summary>A number whose value is either an integer, a real number or bool.</summary>
    /// @author Daniel Dreibrodt
    /// @author Natalia Portillo
    internal class NSNumber : NSObject, IComparable
    {
        /// <summary>
        ///     Indicates that the number's value is an integer. The number is stored as a .NET <see cref="long" />. Its
        ///     original value could have been char, short, int, long or even long long.
        /// </summary>
        public const int INTEGER = 0;

        /// <summary>
        ///     Indicates that the number's value is a real number. The number is stored as a .NET <see cref="double" />. Its
        ///     original value could have been float or double.
        /// </summary>
        public const int REAL = 1;

        /// <summary>Indicates that the number's value is bool.</summary>
        public const int BOOLEAN = 2;
        readonly bool   boolValue;
        readonly double doubleValue;

        readonly long longValue;

        //Holds the current type of this number
        readonly int type;

        /// <summary>
        ///     Parses integers and real numbers from their binary representation.
        ///     <i>Note: real numbers are not yet supported.</i>
        /// </summary>
        /// <param name="bytes">The binary representation</param>
        /// <param name="type">The type of number</param>
        /// <seealso cref="INTEGER" />
        /// <seealso cref="REAL" />
        public NSNumber(ReadOnlySpan<byte> bytes, int type)
        {
            switch(type)
            {
                case INTEGER:
                    doubleValue = longValue = BinaryPropertyListParser.ParseLong(bytes);

                    break;

                case REAL:
                    doubleValue = BinaryPropertyListParser.ParseDouble(bytes);
                    longValue   = (long)Math.Round(doubleValue);

                    break;

                default: throw new ArgumentException("Type argument is not valid.", nameof(type));
            }

            this.type = type;
        }

        public NSNumber(string text, int type)
        {
            switch(type)
            {
                case INTEGER:
                {
                    doubleValue = longValue = long.Parse(text, CultureInfo.InvariantCulture);

                    break;
                }
                case REAL:
                {
                    doubleValue = double.Parse(text, CultureInfo.InvariantCulture);
                    longValue   = (long)Math.Round(doubleValue);

                    break;
                }
                default:
                {
                    throw new ArgumentException("Type argument is not valid.");
                }
            }

            this.type = type;
        }

        /// <summary>Creates a number from its textual representation.</summary>
        /// <param name="text">The textual representation of the number.</param>
        /// <seealso cref="bool.Parse(string)" />
        /// <seealso cref="long.Parse(string)" />
        /// <seealso cref="double.Parse(string, IFormatProvider)" />
        public NSNumber(string text)
        {
            if(text == null)
                throw new ArgumentException("The given string is null and cannot be parsed as number.");

            if(text.StartsWith("0x") &&
               long.TryParse(text.Substring(2), NumberStyles.AllowHexSpecifier, CultureInfo.InvariantCulture,
                             out long l))
            {
                doubleValue = longValue = l;
                type        = INTEGER;
            }
            else if(long.TryParse(text, NumberStyles.Number, CultureInfo.InvariantCulture, out l))
            {
                doubleValue = longValue = l;
                type        = INTEGER;
            }
            else if(double.TryParse(text, NumberStyles.Number, CultureInfo.InvariantCulture, out double d))
            {
                doubleValue = d;
                longValue   = (long)Math.Round(doubleValue);
                type        = REAL;
            }
            else
            {
                bool isTrue = string.Equals(text, "true", StringComparison.CurrentCultureIgnoreCase) ||
                              string.Equals(text, "yes", StringComparison.CurrentCultureIgnoreCase);

                bool isFalse = string.Equals(text, "false", StringComparison.CurrentCultureIgnoreCase) ||
                               string.Equals(text, "no", StringComparison.CurrentCultureIgnoreCase);

                if(isTrue || isFalse)
                {
                    type        = BOOLEAN;
                    boolValue   = isTrue;
                    doubleValue = longValue = boolValue ? 1 : 0;
                }
                else
                    throw new
                        ArgumentException("The given string neither represents a double, an int nor a bool value.");
            }
        }

        /// <summary>Creates an integer number.</summary>
        /// <param name="i">The integer value.</param>
        public NSNumber(int i)
        {
            doubleValue = longValue = i;
            type        = INTEGER;
        }

        /// <summary>Creates an integer number.</summary>
        /// <param name="l">The long integer value.</param>
        public NSNumber(long l)
        {
            doubleValue = longValue = l;
            type        = INTEGER;
        }

        /// <summary>Creates a real number.</summary>
        /// <param name="d">The real value.</param>
        public NSNumber(double d)
        {
            longValue = (long)(doubleValue = d);
            type      = REAL;
        }

        /// <summary>Creates a bool number.</summary>
        /// <param name="b">The bool value.</param>
        public NSNumber(bool b)
        {
            boolValue   = b;
            doubleValue = longValue = b ? 1 : 0;
            type        = BOOLEAN;
        }

        /// <summary>Compares the current <see cref="Squirrel.PropertyList.NSNumber" /> to the specified object.</summary>
        /// <returns>
        ///     0 if the numbers are equal, 1 if the current <see cref="Squirrel.PropertyList.NSNumber" /> is greater than the
        ///     argument and -1 if it is less, or the argument is not a number.
        /// </returns>
        /// <param name="o">Object to compare to the current <see cref="Squirrel.PropertyList.NSNumber" />.</param>
        public int CompareTo(object o)
        {
            double x = ToDouble();
            double y;

            if(o is NSNumber num)
            {
                y = num.ToDouble();

                return x < y
                           ? -1
                           : x == y
                               ? 0
                               : 1;
            }

            if(!IsNumber(o))
                return -1;

            y = GetDoubleFromObject(o);

            return x < y
                       ? -1
                       : x == y
                           ? 0
                           : 1;
        }

        /// <summary>Gets the type of this number's value.</summary>
        /// <returns>The type flag.</returns>
        /// <seealso cref="BOOLEAN" />
        /// <seealso cref="INTEGER" />
        /// <seealso cref="REAL" />
        public int GetNSNumberType() => type;

        /// <summary>Checks whether the value of this NSNumber is a bool.</summary>
        /// <returns>Whether the number's value is a bool.</returns>
        public bool isBoolean() => type == BOOLEAN;

        /// <summary>Checks whether the value of this NSNumber is an integer.</summary>
        /// <returns>Whether the number's value is an integer.</returns>
        public bool isInteger() => type == INTEGER;

        /// <summary>Checks whether the value of this NSNumber is a real number.</summary>
        /// <returns>Whether the number's value is a real number.</returns>
        public bool isReal() => type == REAL;

        /// <summary>The number's bool value.</summary>
        /// <returns><c>true</c> if the value is true or non-zero, <c>false</c> otherwise.</returns>
        public bool ToBool()
        {
            if(type == BOOLEAN)
                return boolValue;

            return longValue != 0;
        }

        /// <summary>The number's long value.</summary>
        /// <returns>The value of the number as long</returns>
        public long ToLong() => longValue;

        /// <summary>
        ///     The number's int value.
        ///     <i>
        ///         Note: Even though the number's type might be INTEGER it can be larger than a Java int. Use intValue() only if
        ///         you are certain that it contains a number from the int range. Otherwise the value might be inaccurate.
        ///     </i>
        /// </summary>
        /// <returns>The value of the number as int.</returns>
        public int ToInt() => (int)longValue;

        /// <summary>The number's double value.</summary>
        /// <returns>The value of the number as double.</returns>
        public double ToDouble() => doubleValue;

        /// <summary>The number's float value. WARNING: Possible loss of precision if the value is outside the float range.</summary>
        /// <returns>The value of the number as float.</returns>
        public float floatValue() => (float)doubleValue;

        /// <summary>Checks whether the other object is a NSNumber of the same value.</summary>
        /// <param name="obj">The object to compare to.</param>
        /// <returns>Whether the objects are equal in terms of numeric value and type.</returns>
        public override bool Equals(object obj)
        {
            if(obj is not NSNumber number)
                return false;

            return type      == number.type && longValue == number.longValue && doubleValue == number.doubleValue &&
                   boolValue == number.boolValue;
        }

        /// <summary>Serves as a hash function for a <see cref="Squirrel.PropertyList.NSNumber" /> object.</summary>
        /// <returns>
        ///     A hash code for this instance that is suitable for use in hashing algorithms and data structures such as a
        ///     hash table.
        /// </returns>
        public override int GetHashCode()
        {
            int hash = type;
            hash = (37 * hash) + (int)(longValue ^ ((uint)longValue >> 32));

            hash = (37 * hash) + (int)(BitConverter.DoubleToInt64Bits(doubleValue) ^
                                       (uint)(BitConverter.DoubleToInt64Bits(doubleValue) >> 32));

            hash = (37 * hash) + (ToBool() ? 1 : 0);

            return hash;
        }

        /// <summary>
        ///     Returns a <see cref="System.String" /> that represents the current
        ///     <see cref="Squirrel.PropertyList.NSNumber" />.
        /// </summary>
        /// <returns>A <see cref="System.String" /> that represents the current <see cref="Squirrel.PropertyList.NSNumber" />.</returns>
        public override string ToString() => type switch
        {
            INTEGER => ToLong().ToString(),
            REAL    => ToDouble().ToString("R", CultureInfo.InvariantCulture),
            BOOLEAN => ToBool().ToString(),
            _       => base.ToString()
        };

        internal override void ToXml(StringBuilder xml, int level)
        {
            Indent(xml, level);

            switch(type)
            {
                case INTEGER:
                {
                    xml.Append("<integer>");
                    xml.Append(ToLong());
                    xml.Append("</integer>");

                    break;
                }
                case REAL:
                {
                    xml.Append("<real>");

                    if(doubleValue == 0)
                        xml.Append("0.0");
                    else
                        xml.Append(ToDouble().ToString("R", CultureInfo.InvariantCulture));

                    xml.Append("</real>");

                    break;
                }
                case BOOLEAN:
                {
                    xml.Append(ToBool() ? "<true/>" : "<false/>");

                    break;
                }
            }
        }

        internal override void ToBinary(BinaryPropertyListWriter outPlist)
        {
            switch(GetNSNumberType())
            {
                case INTEGER:
                {
                    if(ToLong() < 0)
                    {
                        outPlist.Write(0x13);
                        outPlist.WriteBytes(ToLong(), 8);
                    }
                    else if(ToLong() <= 0xff)
                    {
                        outPlist.Write(0x10);
                        outPlist.WriteBytes(ToLong(), 1);
                    }
                    else if(ToLong() <= 0xffff)
                    {
                        outPlist.Write(0x11);
                        outPlist.WriteBytes(ToLong(), 2);
                    }
                    else if(ToLong() <= 0xffffffffL)
                    {
                        outPlist.Write(0x12);
                        outPlist.WriteBytes(ToLong(), 4);
                    }
                    else
                    {
                        outPlist.Write(0x13);
                        outPlist.WriteBytes(ToLong(), 8);
                    }

                    break;
                }
                case REAL:
                {
                    outPlist.Write(0x23);
                    outPlist.WriteDouble(ToDouble());

                    break;
                }
                case BOOLEAN:
                {
                    outPlist.Write(ToBool() ? 0x09 : 0x08);

                    break;
                }
            }
        }

        internal override void ToASCII(StringBuilder ascii, int level)
        {
            Indent(ascii, level);

            if(type == BOOLEAN)
                ascii.Append(boolValue ? "YES" : "NO");
            else
                ascii.Append(ToString());
        }

        internal override void ToASCIIGnuStep(StringBuilder ascii, int level)
        {
            Indent(ascii, level);

            switch(type)
            {
                case INTEGER:
                {
                    ascii.Append("<*I");
                    ascii.Append(ToString());
                    ascii.Append(">");

                    break;
                }
                case REAL:
                {
                    ascii.Append("<*R");
                    ascii.Append(ToString());
                    ascii.Append(">");

                    break;
                }
                case BOOLEAN:
                {
                    ascii.Append(boolValue ? "<*BY>" : "<*BN>");

                    break;
                }
            }
        }

        /// <summary>Determines if an object is a number. Substitutes .NET's Number class comparison</summary>
        /// <returns><c>true</c> if it is a number.</returns>
        /// <param name="o">Object.</param>
        static bool IsNumber(object o) =>
            o is sbyte or byte or short or ushort or int or uint or long or ulong or float or double or decimal;

        static double GetDoubleFromObject(object o) => o switch
        {
            sbyte @sbyte     => @sbyte,
            byte b           => b,
            short s          => s,
            ushort @ushort   => @ushort,
            int i            => i,
            uint u           => u,
            long l           => l,
            ulong @ulong     => @ulong,
            float f          => f,
            double d         => d,
            decimal @decimal => (double)@decimal,
            _                => 0
        };

        /// <summary>
        ///     Determines whether the specified <see cref="Squirrel.PropertyList.NSObject" /> is equal to the current
        ///     <see cref="Squirrel.PropertyList.NSNumber" />.
        /// </summary>
        /// <param name="obj">
        ///     The <see cref="Squirrel.PropertyList.NSObject" /> to compare with the current
        ///     <see cref="Squirrel.PropertyList.NSNumber" />.
        /// </param>
        /// <returns>
        ///     <c>true</c> if the specified <see cref="Squirrel.PropertyList.NSObject" /> is equal to the current
        ///     <see cref="Squirrel.PropertyList.NSNumber" />; otherwise, <c>false</c>.
        /// </returns>
        public override bool Equals(NSObject obj)
        {
            if(obj is not NSNumber number)
                return false;

            if(number.GetNSNumberType() != type)
                return false;

            return type switch
            {
                INTEGER => longValue   == number.ToLong(),
                REAL    => doubleValue == number.ToDouble(),
                BOOLEAN => boolValue   == number.ToBool(),
                _       => false
            };
        }

        public static explicit operator ulong(NSNumber value) => (ulong)value.longValue;

        public static explicit operator long(NSNumber value) => value.longValue;

        public static explicit operator uint(NSNumber value) => (uint)value.longValue;

        public static explicit operator int(NSNumber value) => (int)value.longValue;

        public static explicit operator ushort(NSNumber value) => (ushort)value.longValue;

        public static explicit operator short(NSNumber value) => (short)value.longValue;

        public static explicit operator byte(NSNumber value) => (byte)value.longValue;

        public static explicit operator sbyte(NSNumber value) => (sbyte)value.longValue;

        public static explicit operator double(NSNumber value) => value.doubleValue;

        public static explicit operator float(NSNumber value) => (float)value.doubleValue;

        public static explicit operator bool(NSNumber value) => value.boolValue;

        public static explicit operator NSNumber(ulong value) => new(value);

        public static explicit operator NSNumber(long value) => new(value);

        public static explicit operator NSNumber(uint value) => new(value);

        public static explicit operator NSNumber(int value) => new(value);

        public static explicit operator NSNumber(ushort value) => new(value);

        public static explicit operator NSNumber(short value) => new(value);

        public static explicit operator NSNumber(byte value) => new(value);

        public static explicit operator NSNumber(sbyte value) => new(value);

        public static explicit operator NSNumber(double value) => new(value);

        public static explicit operator NSNumber(float value) => new(value);

        public static explicit operator NSNumber(bool value) => new(value);
    }
}

// NSObject.cs
namespace Squirrel.Packaging.OSX
{
    /// <summary>
    ///     <para>Abstract interface for any object contained in a property list.</para>
    ///     <para>The names and functions of the various objects orient themselves towards Apple's Cocoa API.</para>
    /// </summary>
    /// @author Daniel Dreibrodt
    /// @author Natalia Portillo
    internal abstract class NSObject
    {
        /// <summary>
        ///     The newline character used for generating the XML output. To maintain compatibility with the Apple format,
        ///     only a newline character is used (as opposed to cr+lf which is normally used on Windows).
        /// </summary>
        internal static readonly string NEWLINE = "\n";

        /// <summary>The indentation character used for generating the XML output. This is the tabulator character.</summary>
        static readonly string INDENT = "\t";

        /// <summary>
        ///     The maximum length of the text lines to be used when generating ASCII property lists. But this number is only
        ///     a guideline it is not guaranteed that it will not be overstepped.
        /// </summary>
        internal static readonly int ASCII_LINE_LENGTH = 80;

        /// <summary>Generates the XML representation of the object (without XML headers or enclosing plist-tags).</summary>
        /// <param name="xml">The StringBuilder onto which the XML representation is appended.</param>
        /// <param name="level">The indentation level of the object.</param>
        internal abstract void ToXml(StringBuilder xml, int level);

        /// <summary>Assigns IDs to all the objects in this NSObject subtree.</summary>
        /// <param name="outPlist">The writer object that handles the binary serialization.</param>
        internal virtual void AssignIDs(BinaryPropertyListWriter outPlist) => outPlist.AssignID(this);

        /// <summary>Generates the binary representation of the object.</summary>
        /// <param name="outPlist">The output stream to serialize the object to.</param>
        internal abstract void ToBinary(BinaryPropertyListWriter outPlist);

        /// <summary>Generates a valid XML property list including headers using this object as root.</summary>
        /// <returns>The XML representation of the property list including XML header and doctype information.</returns>
        public string ToXmlPropertyList()
        {
            var xml = new StringBuilder("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
            xml.Append(NEWLINE);
            xml.Append("<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">");
            xml.Append(NEWLINE);
            xml.Append("<plist version=\"1.0\">");
            xml.Append(NEWLINE);
            ToXml(xml, 0);
            xml.Append(NEWLINE);
            xml.Append("</plist>");
            xml.Append(NEWLINE);

            return xml.ToString();
        }

        /// <summary>
        ///     Generates the ASCII representation of this object. The generated ASCII representation does not end with a
        ///     newline. Complies with
        ///     https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/PropertyLists/OldStylePlists/OldStylePLists.html
        /// </summary>
        /// <param name="ascii">The StringBuilder onto which the ASCII representation is appended.</param>
        /// <param name="level">The indentation level of the object.</param>
        internal abstract void ToASCII(StringBuilder ascii, int level);

        /// <summary>
        ///     Generates the ASCII representation of this object in the GnuStep format. The generated ASCII representation
        ///     does not end with a newline.
        /// </summary>
        /// <param name="ascii">The StringBuilder onto which the ASCII representation is appended.</param>
        /// <param name="level">The indentation level of the object.</param>
        internal abstract void ToASCIIGnuStep(StringBuilder ascii, int level);

        /// <summary>
        ///     Helper method that adds correct indentation to the xml output. Calling this method will add <c>level</c>
        ///     number of tab characters to the <c>xml</c> string.
        /// </summary>
        /// <param name="xml">The string builder for the XML document.</param>
        /// <param name="level">The level of indentation.</param>
        internal static void Indent(StringBuilder xml, int level)
        {
            for(int i = 0; i < level; i++)
                xml.Append(INDENT);
        }

        /// <summary>Wraps the given value inside a NSObject.</summary>
        /// <param name="value">The value to represent as a NSObject.</param>
        /// <returns>A NSObject representing the given value.</returns>
        public static NSNumber Wrap(long value) => new(value);

        /// <summary>Wraps the given value inside a NSObject.</summary>
        /// <param name="value">The value to represent as a NSObject.</param>
        /// <returns>A NSObject representing the given value.</returns>
        public static NSNumber Wrap(double value) => new(value);

        /// <summary>Wraps the given value inside a NSObject.</summary>
        /// <param name="value">The value to represent as a NSObject.</param>
        /// <returns>A NSObject representing the given value.</returns>
        public static NSNumber Wrap(bool value) => new(value);

        /// <summary>Wraps the given value inside a NSObject.</summary>
        /// <param name="value">The value to represent as a NSObject.</param>
        /// <returns>A NSObject representing the given value.</returns>
        public static NSData Wrap(byte[] value) => new(value);

        /// <summary>Creates a NSArray with the contents of the given array.</summary>
        /// <param name="value">The value to represent as a NSObject.</param>
        /// <returns>A NSObject representing the given value.</returns>
        /// <exception cref="SystemException">When one of the objects contained in the array cannot be represented by a NSObject.</exception>
        public static NSArray Wrap(object[] value)
        {
            var arr = new NSArray(value.Length);

            for(int i = 0; i < value.Length; i++)
                arr.Add(Wrap(value[i]));

            return arr;
        }

        /// <summary>Creates a NSDictionary with the contents of the given map.</summary>
        /// <param name="value">The value to represent as a NSObject.</param>
        /// <returns>A NSObject representing the given value.</returns>
        /// <exception cref="SystemException">When one of the values contained in the map cannot be represented by a NSObject.</exception>
        public static NSDictionary Wrap(Dictionary<string, object> value)
        {
            var dict = new NSDictionary();

            foreach(KeyValuePair<string, object> kvp in value)
                dict.Add(kvp.Key, Wrap(kvp.Value));

            return dict;
        }

        /// <summary>Creates a NSSet with the contents of this set.</summary>
        /// <param name="value">The value to represent as a NSObject.</param>
        /// <returns>A NSObject representing the given value.</returns>
        /// <exception cref="SystemException">When one of the values contained in the map cannot be represented by a NSObject.</exception>
        public static NSSet Wrap(List<object> value)
        {
            var set = new NSSet();

            foreach(object o in value)
                set.AddObject(Wrap(o));

            return set;
        }

        /// <summary>
        ///     <para>Creates a NSObject representing the given .NET Object.</para>
        ///     <para>
        ///         Numerics of type <see cref="bool" />, <see cref="int" />, <see cref="long" />, <see cref="short" />,
        ///         <see cref="byte" />, <see cref="float" /> or <see cref="double" /> are wrapped as NSNumber objects.
        ///     </para>
        ///     <para>Strings are wrapped as <see cref="NSString" /> objects and byte arrays as <see cref="NSData" /> objects.</para>
        ///     <para>DateTime objects are wrapped as <see cref="NSDate" /> objects.</para>
        ///     <para>Serializable classes are serialized and their data is stored in <see cref="NSData" /> objects.</para>
        ///     <para>
        ///         Arrays and Collection objects are converted to <see cref="NSArray" /> where each array member is wrapped into
        ///         a <see cref="NSObject" />.
        ///     </para>
        ///     <para>
        ///         Dictionaries are converted to <see cref="NSDictionary" />. Each key is converted to a string and each value
        ///         wrapped into a <see cref="NSObject" />.
        ///     </para>
        /// </summary>
        /// <param name="o">The object to represent.</param>
        /// <returns>A NSObject equivalent to the given object.</returns>
        public static NSObject Wrap(object o)
        {
            if(o == null)
                throw new NullReferenceException("A null object cannot be wrapped as a NSObject");

            if(o is NSObject nsObject)
                return nsObject;

            Type c = o.GetType();

            if(typeof(bool).Equals(c))
                return Wrap((bool)o);

            if(typeof(byte).Equals(c))
                return Wrap((byte)o);

            if(typeof(short).Equals(c))
                return Wrap((short)o);

            if(typeof(int).Equals(c))
                return Wrap((int)o);

            if(typeof(long).IsAssignableFrom(c))
                return Wrap((long)o);

            if(typeof(float).Equals(c))
                return Wrap((float)o);

            if(typeof(double).IsAssignableFrom(c))
                return Wrap((double)o);

            if(typeof(string).Equals(c))
                return new NSString((string)o);

            if(typeof(DateTime).Equals(c))
                return new NSDate((DateTime)o);

            if(c.IsArray)
            {
                Type cc = c.GetElementType();

                if(cc.Equals(typeof(byte)))
                    return Wrap((byte[])o);

                if(cc.Equals(typeof(bool)))
                {
                    bool[] array = (bool[])o;
                    var    nsa   = new NSArray(array.Length);

                    for(int i = 0; i < array.Length; i++)
                        nsa.Add(Wrap(array[i]));

                    return nsa;
                }

                if(cc.Equals(typeof(float)))
                {
                    float[] array = (float[])o;
                    var     nsa   = new NSArray(array.Length);

                    for(int i = 0; i < array.Length; i++)
                        nsa.Add(Wrap(array[i]));

                    return nsa;
                }

                if(cc.Equals(typeof(double)))
                {
                    double[] array = (double[])o;
                    var      nsa   = new NSArray(array.Length);

                    for(int i = 0; i < array.Length; i++)
                        nsa.Add(Wrap(array[i]));

                    return nsa;
                }

                if(cc.Equals(typeof(short)))
                {
                    short[] array = (short[])o;
                    var     nsa   = new NSArray(array.Length);

                    for(int i = 0; i < array.Length; i++)
                        nsa.Add(Wrap(array[i]));

                    return nsa;
                }

                if(cc.Equals(typeof(int)))
                {
                    int[] array = (int[])o;
                    var   nsa   = new NSArray(array.Length);

                    for(int i = 0; i < array.Length; i++)
                        nsa.Add(Wrap(array[i]));

                    return nsa;
                }

                if(cc.Equals(typeof(long)))
                {
                    long[] array = (long[])o;
                    var    nsa   = new NSArray(array.Length);

                    for(int i = 0; i < array.Length; i++)
                        nsa.Add(Wrap(array[i]));

                    return nsa;
                }

                return Wrap((object[])o);
            }

            if(typeof(Dictionary<string, object>).IsAssignableFrom(c))
            {
                Dictionary<string, object> netDict = (Dictionary<string, object>)o;
                var                        dict    = new NSDictionary();

                foreach(KeyValuePair<string, object> kvp in netDict)
                    dict.Add(kvp.Key, Wrap(kvp.Value));

                return dict;
            }

            if(typeof(List<object>).IsAssignableFrom(c))
                return Wrap(((List<object>)o).ToArray());

            throw new PropertyListException($"Cannot wrap an object of type {o.GetType().Name}.");
        }

        /// <summary>
        ///     Converts this NSObject into an equivalent object of the .NET Runtime Environment.
        ///     <para><see cref="NSArray" /> objects are converted to arrays.</para>
        ///     <para>
        ///         <see cref="NSDictionary" /> objects are converted to objects extending the
        ///         <see cref="Dictionary{TKey, TValue}" /> class.
        ///     </para>
        ///     <para><see cref="NSSet" /> objects are converted to objects extending the <see cref="List{NSObject}" /> class.</para>
        ///     <para>
        ///         <see cref="NSNumber" /> objects are converted to primitive number values (<see cref="int" />,
        ///         <see cref="long" />, <see cref="double" /> or <see cref="bool" />).
        ///     </para>
        ///     <para><see cref="NSString" /> objects are converted to <see cref="string" /> objects.</para>
        ///     <para><see cref="NSData" /> objects are converted to <see cref="byte" /> arrays.</para>
        ///     <para><see cref="NSDate" /> objects are converted to <see cref="System.DateTime" /> objects.</para>
        ///     <para><see cref="UID" /> objects are converted to <see cref="byte" /> arrays.</para>
        /// </summary>
        /// <returns>A native .NET object representing this NSObject's value.</returns>
        public object ToObject()
        {
            switch(this)
            {
                case NSArray:
                {
                    var      nsArray = (NSArray)this;
                    object[] array   = new object[nsArray.Count];

                    for(int i = 0; i < nsArray.Count; i++)
                        array[i] = nsArray[i].ToObject();

                    return array;
                }
                case NSDictionary:
                {
                    Dictionary<string, NSObject> dictA = ((NSDictionary)this).GetDictionary();
                    Dictionary<string, object>   dictB = new(dictA.Count);

                    foreach(KeyValuePair<string, NSObject> kvp in dictA)
                        dictB.Add(kvp.Key, kvp.Value.ToObject());

                    return dictB;
                }
                case NSSet:
                {
                    List<NSObject> setA = ((NSSet)this).GetSet();
                    List<object>   setB = new();

                    foreach(NSObject o in setA)
                        setB.Add(o.ToObject());

                    return setB;
                }
                case NSNumber:
                {
                    var num = (NSNumber)this;

                    switch(num.GetNSNumberType())
                    {
                        case NSNumber.INTEGER:
                        {
                            long longVal = num.ToLong();

                            if(longVal is > int.MaxValue or < int.MinValue)
                                return longVal;

                            return num.ToInt();
                        }
                        case NSNumber.REAL:    return num.ToDouble();
                        case NSNumber.BOOLEAN: return num.ToBool();
                        default:               return num.ToDouble();
                    }

                    break;
                }
                case NSString: return ((NSString)this).Content;
                case NSData:   return ((NSData)this).Bytes;
                case NSDate:   return ((NSDate)this).Date;
                case UID:      return ((UID)this).Bytes;
                default:       return this;
            }
        }

        internal static bool ArrayEquals(byte[] arrayA, byte[] arrayB)
        {
            if(arrayA.Length != arrayB.Length)
                return false;

            for(int i = 0; i < arrayA.Length; i++)
                if(arrayA[i] != arrayB[i])
                    return false;

            return true;
        }

        internal static bool ArrayEquals(IList<NSObject> arrayA, IList<NSObject> arrayB)
        {
            if(arrayA.Count != arrayB.Count)
                return false;

            for(int i = 0; i < arrayA.Count; i++)
                if(arrayA[i] != arrayB[i])
                    return false;

            return true;
        }

        /// <summary>Determines if the specific NSObject is the same as the NSObject overriding this method.</summary>
        /// <param name="obj">
        ///     The <see cref="Squirrel.PropertyList.NSObject" /> to compare with the current
        ///     <see cref="Squirrel.PropertyList.NSObject" />.
        /// </param>
        /// <returns>
        ///     <c>true</c> if the specified <see cref="Squirrel.PropertyList.NSObject" /> is equal to the current
        ///     <see cref="Squirrel.PropertyList.NSObject" />; otherwise, <c>false</c>.
        /// </returns>
        public abstract bool Equals(NSObject obj);
    }
}

// NSSet.cs
namespace Squirrel.Packaging.OSX
{
    /// <summary>
    ///     <para>A set is an interface to an unordered collection of objects.</para>
    ///     <para>This implementation uses a <see cref="List{T}" />as the underlying data structure.</para>
    /// </summary>
    /// @author Daniel Dreibrodt
    /// @author Natalia Portillo
    internal class NSSet : NSObject, IEnumerable
    {
        readonly bool           ordered;
        readonly List<NSObject> set;

        /// <summary>Creates an empty unordered set.</summary>
        public NSSet() => set = new List<NSObject>();

        /// <summary>Creates an empty set.</summary>
        /// <param name="ordered">Should the set be ordered on operations?</param>
        public NSSet(bool ordered)
        {
            this.ordered = ordered;
            set          = new List<NSObject>();
        }

        /// <summary>Creates a set and fill it with the given objects.</summary>
        /// <param name="objects">The objects to populate the set.</param>
        public NSSet(params NSObject[] objects) => set = new List<NSObject>(objects);

        /// <summary>Creates a set and fill it with the given objects.</summary>
        /// <param name="objects">The objects to populate the set.</param>
        /// <param name="ordered">Should the set be ordered on operations?</param>
        public NSSet(bool ordered, params NSObject[] objects)
        {
            this.ordered = ordered;
            set          = new List<NSObject>(objects);

            if(ordered)
                set.Sort();
        }

        /// <summary>Gets the number of elements in the set.</summary>
        /// <value>The number of elements in the set.</value>
        public int Count
        {
            get
            {
                lock(set)
                    return set.Count;
            }
        }

        /// <summary>
        ///     Returns an enumerator object that lets you iterate over all elements of the set. This is the equivalent to
        ///     <c>objectEnumerator</c> in the Cocoa implementation of NSSet.
        /// </summary>
        /// <returns>The iterator for the set.</returns>
        public IEnumerator GetEnumerator()
        {
            lock(set)
                return set.GetEnumerator();
        }

        /// <summary>Adds an object to the set.</summary>
        /// <param name="obj">The object to add.</param>
        public void AddObject(NSObject obj)
        {
            lock(set)
            {
                set.Add(obj);

                if(ordered)
                    set.Sort();
            }
        }

        /// <summary>Removes an object from the set.</summary>
        /// <param name="obj">The object to remove.</param>
        public void RemoveObject(NSObject obj)
        {
            lock(set)
            {
                set.Remove(obj);

                if(ordered)
                    set.Sort();
            }
        }

        /// <summary>Returns all objects contained in the set.</summary>
        /// <returns>An array of all objects in the set.</returns>
        public NSObject[] AllObjects()
        {
            lock(set)
                return set.ToArray();
        }

        /// <summary>Returns one of the objects in the set, or <c>null</c> if the set contains no objects.</summary>
        /// <returns>The first object in the set, or <c>null</c> if the set is empty.</returns>
        public NSObject AnyObject()
        {
            lock(set)
                return set.Count == 0 ? null : set[0];
        }

        /// <summary>Finds out whether a given object is contained in the set.</summary>
        /// <returns><c>true</c>, when the object was found, <c>false</c> otherwise.</returns>
        /// <param name="obj">The object to look for.</param>
        public bool ContainsObject(NSObject obj) => set.Contains(obj);

        /// <summary>
        ///     Determines whether the set contains an object equal to a given object and returns that object if it is
        ///     present.
        /// </summary>
        /// <param name="obj">The object to look for.</param>
        /// <returns>The object if it is present, <c>null</c> otherwise.</returns>
        public NSObject Member(NSObject obj)
        {
            lock(set)
            {
                foreach(NSObject o in set)
                    if(o.Equals(obj))
                        return o;

                return null;
            }
        }

        /// <summary>Finds out whether at least one object is present in both sets.</summary>
        /// <returns><c>true</c> if the intersection of both sets is empty, <c>false</c> otherwise.</returns>
        /// <param name="otherSet">The other set.</param>
        public bool IntersectsSet(NSSet otherSet)
        {
            lock(set)
            {
                foreach(NSObject o in set)
                    if(otherSet.ContainsObject(o))
                        return true;

                return false;
            }
        }

        /// <summary>Finds out if this set is a subset of the given set.</summary>
        /// <returns><c>true</c> if all elements in this set are also present in the other set, <c>false</c>otherwise.</returns>
        /// <param name="otherSet">The other set.</param>
        public bool IsSubsetOfSet(NSSet otherSet)
        {
            lock(set)
            {
                foreach(NSObject o in set)
                    if(!otherSet.ContainsObject(o))
                        return false;

                return true;
            }
        }

        /// <summary>Gets the underlying data structure in which this NSSets stores its content.</summary>
        /// <returns>A Set object.</returns>
        internal List<NSObject> GetSet() => set;

        /// <summary>Serves as a hash function for a <see cref="Squirrel.PropertyList.NSSet" /> object.</summary>
        /// <returns>
        ///     A hash code for this instance that is suitable for use in hashing algorithms and data structures such as a
        ///     hash table.
        /// </returns>
        public override int GetHashCode()
        {
            int hash = 7;
            hash = (29 * hash) + (set != null ? set.GetHashCode() : 0);

            return hash;
        }

        /// <summary>
        ///     Determines whether the specified <see cref="System.Object" /> is equal to the current
        ///     <see cref="Squirrel.PropertyList.NSSet" />.
        /// </summary>
        /// <param name="obj">
        ///     The <see cref="System.Object" /> to compare with the current
        ///     <see cref="Squirrel.PropertyList.NSSet" />.
        /// </param>
        /// <returns>
        ///     <c>true</c> if the specified <see cref="System.Object" /> is equal to the current
        ///     <see cref="Squirrel.PropertyList.NSSet" />; otherwise, <c>false</c>.
        /// </returns>
        public override bool Equals(object obj)
        {
            if(obj == null)
                return false;

            if(GetType() != obj.GetType())
                return false;

            var other = (NSSet)obj;

            return !(set != other.set && (set == null || !set.Equals(other.set)));
        }

        /// <summary>
        ///     Returns the XML representation for this set. There is no official XML representation specified for sets. In
        ///     this implementation it is represented by an array.
        /// </summary>
        /// <param name="xml">The XML StringBuilder</param>
        /// <param name="level">The indentation level</param>
        internal override void ToXml(StringBuilder xml, int level)
        {
            Indent(xml, level);
            xml.Append("<array>");
            xml.Append(NEWLINE);

            if(ordered)
                set.Sort();

            foreach(NSObject o in set)
            {
                o.ToXml(xml, level + 1);
                xml.Append(NEWLINE);
            }

            Indent(xml, level);
            xml.Append("</array>");
        }

        internal override void AssignIDs(BinaryPropertyListWriter outPlist)
        {
            base.AssignIDs(outPlist);

            foreach(NSObject obj in set)
                obj.AssignIDs(outPlist);
        }

        internal override void ToBinary(BinaryPropertyListWriter outPlist)
        {
            if(ordered)
            {
                set.Sort();
                outPlist.WriteIntHeader(0xB, set.Count);
            }
            else
                outPlist.WriteIntHeader(0xC, set.Count);

            foreach(NSObject obj in set)
                outPlist.WriteID(outPlist.GetID(obj));
        }

        /// <summary>
        ///     Returns the ASCII representation of this set. There is no official ASCII representation for sets. In this
        ///     implementation sets are represented as arrays.
        /// </summary>
        /// <param name="ascii">The ASCII file string builder</param>
        /// <param name="level">The indentation level</param>
        internal override void ToASCII(StringBuilder ascii, int level)
        {
            Indent(ascii, level);

            if(ordered)
                set.Sort();

            NSObject[] array = AllObjects();
            ascii.Append(ASCIIPropertyListParser.ARRAY_BEGIN_TOKEN);
            int indexOfLastNewLine = ascii.ToString().LastIndexOf(NEWLINE, StringComparison.Ordinal);

            for(int i = 0; i < array.Length; i++)
            {
                Type objClass = array[i].GetType();

                if((objClass.Equals(typeof(NSDictionary)) || objClass.Equals(typeof(NSArray)) ||
                    objClass.Equals(typeof(NSData))) &&
                   indexOfLastNewLine != ascii.Length)
                {
                    ascii.Append(NEWLINE);
                    indexOfLastNewLine = ascii.Length;
                    array[i].ToASCII(ascii, level + 1);
                }
                else
                {
                    if(i != 0)
                        ascii.Append(" ");

                    array[i].ToASCII(ascii, 0);
                }

                if(i != array.Length - 1)
                    ascii.Append(ASCIIPropertyListParser.ARRAY_ITEM_DELIMITER_TOKEN);

                if(ascii.Length - indexOfLastNewLine <= ASCII_LINE_LENGTH)
                    continue;

                ascii.Append(NEWLINE);
                indexOfLastNewLine = ascii.Length;
            }

            ascii.Append(ASCIIPropertyListParser.ARRAY_END_TOKEN);
        }

        /// <summary>
        ///     Returns the ASCII representation of this set according to the GnuStep format. There is no official ASCII
        ///     representation for sets. In this implementation sets are represented as arrays.
        /// </summary>
        /// <param name="ascii">The ASCII file string builder</param>
        /// <param name="level">The indentation level</param>
        internal override void ToASCIIGnuStep(StringBuilder ascii, int level)
        {
            Indent(ascii, level);

            if(ordered)
                set.Sort();

            NSObject[] array = AllObjects();
            ascii.Append(ASCIIPropertyListParser.ARRAY_BEGIN_TOKEN);
            int indexOfLastNewLine = ascii.ToString().LastIndexOf(NEWLINE, StringComparison.Ordinal);

            for(int i = 0; i < array.Length; i++)
            {
                if(array[i] is NSDictionary or NSArray or NSData &&
                   indexOfLastNewLine != ascii.Length)
                {
                    ascii.Append(NEWLINE);
                    indexOfLastNewLine = ascii.Length;
                    array[i].ToASCIIGnuStep(ascii, level + 1);
                }
                else
                {
                    if(i != 0)
                        ascii.Append(" ");

                    array[i].ToASCIIGnuStep(ascii, 0);
                }

                if(i != array.Length - 1)
                    ascii.Append(ASCIIPropertyListParser.ARRAY_ITEM_DELIMITER_TOKEN);

                if(ascii.Length - indexOfLastNewLine <= ASCII_LINE_LENGTH)
                    continue;

                ascii.Append(NEWLINE);
                indexOfLastNewLine = ascii.Length;
            }

            ascii.Append(ASCIIPropertyListParser.ARRAY_END_TOKEN);
        }

        /// <summary>
        ///     Determines whether the specified <see cref="Squirrel.PropertyList.NSObject" /> is equal to the current
        ///     <see cref="Squirrel.PropertyList.NSSet" />.
        /// </summary>
        /// <param name="obj">
        ///     The <see cref="Squirrel.PropertyList.NSObject" /> to compare with the current
        ///     <see cref="Squirrel.PropertyList.NSSet" />.
        /// </param>
        /// <returns>
        ///     <c>true</c> if the specified <see cref="Squirrel.PropertyList.NSObject" /> is equal to the current
        ///     <see cref="Squirrel.PropertyList.NSSet" />; otherwise, <c>false</c>.
        /// </returns>
        public override bool Equals(NSObject obj)
        {
            if(obj is not NSSet nsSet)
                return false;

            if(set.Count != nsSet.Count)
                return false;

            foreach(NSObject objS in nsSet)
                if(!set.Contains(objS))
                    return false;

            return true;
        }
    }
}

// NSString.cs
namespace Squirrel.Packaging.OSX
{
    /// <summary>A NSString contains a string.</summary>
    /// @author Daniel Dreibrodt
    /// @author Natalia Portillo
    internal class NSString : NSObject, IComparable
    {
        static Encoding asciiEncoder, utf16beEncoder, utf8Encoder;

        /// <summary>Creates a NSString from its binary representation.</summary>
        /// <param name="bytes">The binary representation.</param>
        /// <param name="encoding">The encoding of the binary representation, the name of a supported charset.</param>
        /// <exception cref="ArgumentException">The encoding charset is invalid or not supported by the underlying platform.</exception>
        public NSString(ReadOnlySpan<byte> bytes, string encoding) : this(bytes, Encoding.GetEncoding(encoding)) {}

        /// <summary>Creates a NSString from its binary representation.</summary>
        /// <param name="bytes">The binary representation.</param>
        /// <param name="encoding">The encoding of the binary representation.</param>
        /// <exception cref="ArgumentException">The encoding charset is invalid or not supported by the underlying platform.</exception>
        public NSString(ReadOnlySpan<byte> bytes, Encoding encoding)
        {
        #if NATIVE_SPAN
            Content = encoding.GetString(bytes);
        #else
            Content = encoding.GetString(bytes.ToArray());
        #endif
        }

        /// <summary>Creates a NSString from a string.</summary>
        /// <param name="text">The string that will be contained in the NSString.</param>
        public NSString(string text) => Content = text;

        /// <summary>Gets this strings content.</summary>
        /// <returns>This NSString as .NET string object.</returns>
        public string Content { get; set; }

        /// <summary>Compares the current <see cref="Squirrel.PropertyList.NSString" /> to the specified object.</summary>
        /// <returns>A 32-bit signed integer that indicates the lexical relationship between the two comparands.</returns>
        /// <param name="o">Object to compare to the current <see cref="Squirrel.PropertyList.NSString" />.</param>
        public int CompareTo(object o) => o switch
        {
            NSString nsString => string.Compare(Content, nsString.Content, StringComparison.Ordinal),
            string s          => string.Compare(Content, s, StringComparison.Ordinal),
            _                 => -1
        };

        /// <summary>Appends a string to this string.</summary>
        /// <param name="s">The string to append.</param>
        public void Append(NSString s) => Append(s.Content);

        /// <summary>Appends a string to this string.</summary>
        /// <param name="s">The string to append.</param>
        public void Append(string s) => Content += s;

        /// <summary>Prepends a string to this string.</summary>
        /// <param name="s">The string to prepend.</param>
        public void Prepend(string s) => Content = s + Content;

        /// <summary>Prepends a string to this string.</summary>
        /// <param name="s">The string to prepend.</param>
        public void Prepend(NSString s) => Prepend(s.Content);

        /// <summary>
        ///     Determines whether the specified <see cref="System.Object" /> is equal to the current
        ///     <see cref="Squirrel.PropertyList.NSString" />.
        /// </summary>
        /// <param name="obj">
        ///     The <see cref="System.Object" /> to compare with the current
        ///     <see cref="Squirrel.PropertyList.NSString" />.
        /// </param>
        /// <returns>
        ///     <c>true</c> if the specified <see cref="System.Object" /> is equal to the current
        ///     <see cref="Squirrel.PropertyList.NSString" />; otherwise, <c>false</c>.
        /// </returns>
        public override bool Equals(object obj) => obj is NSString nsString && Content.Equals(nsString.Content);

        /// <summary>Serves as a hash function for a <see cref="Squirrel.PropertyList.NSString" /> object.</summary>
        /// <returns>
        ///     A hash code for this instance that is suitable for use in hashing algorithms and data structures such as a
        ///     hash table.
        /// </returns>
        public override int GetHashCode() => Content.GetHashCode();

        /// <summary>The textual representation of this NSString.</summary>
        /// <returns>The NSString's contents.</returns>
        public override string ToString() => Content;

        internal override void ToXml(StringBuilder xml, int level)
        {
            Indent(xml, level);
            xml.Append("<string>");

            //Make sure that the string is encoded in UTF-8 for the XML output
            lock(typeof(NSString))
            {
                utf8Encoder ??= Encoding.GetEncoding("UTF-8");

                try
                {
                    byte[] bytes = utf8Encoder.GetBytes(Content);
                    Content = utf8Encoder.GetString(bytes);
                }
                catch(Exception ex)
                {
                    throw new PropertyListException("Could not encode the NSString into UTF-8: " + ex.Message);
                }
            }

            //According to http://www.w3.org/TR/REC-xml/#syntax node values must not
            //contain the characters < or &. Also the > character should be escaped.
            if(Content.Contains("&") ||
               Content.Contains("<") ||
               Content.Contains(">"))
            {
                xml.Append("<![CDATA[");
                xml.Append(Content.Replace("]]>", "]]]]><![CDATA[>"));
                xml.Append("]]>");
            }
            else
                xml.Append(Content);

            xml.Append("</string>");
        }

        internal override void ToBinary(BinaryPropertyListWriter outPlist)
        {
            int    kind;
            byte[] byteBuf;

            lock(typeof(NSString))
            {
                // Not much use, because some characters do not fallback to exception, even if not ASCII
                asciiEncoder ??= Encoding.GetEncoding("ascii", EncoderFallback.ExceptionFallback,
                                                      DecoderFallback.ExceptionFallback);

                if(IsASCIIEncodable(Content))
                {
                    kind    = 0x5; // standard ASCII
                    byteBuf = asciiEncoder.GetBytes(Content);
                }
                else
                {
                    utf16beEncoder ??= Encoding.BigEndianUnicode;

                    kind    = 0x6; // UTF-16-BE
                    byteBuf = utf16beEncoder.GetBytes(Content);
                }
            }

            outPlist.WriteIntHeader(kind, Content.Length);
            outPlist.Write(byteBuf);
        }

        internal override void ToASCII(StringBuilder ascii, int level)
        {
            Indent(ascii, level);
            ascii.Append("\"");

            //According to https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/PropertyLists/OldStylePlists/OldStylePLists.html
            //non-ASCII characters are not escaped but simply written into the
            //file, thus actually violating the ASCII plain text format.
            //We will escape the string anyway because current Xcode project files (ASCII property lists) also escape their strings.
            ascii.Append(EscapeStringForASCII(Content));
            ascii.Append("\"");
        }

        internal override void ToASCIIGnuStep(StringBuilder ascii, int level)
        {
            Indent(ascii, level);
            ascii.Append("\"");
            ascii.Append(EscapeStringForASCII(Content));
            ascii.Append("\"");
        }

        /// <summary>Escapes a string for use in ASCII property lists.</summary>
        /// <returns>The unescaped string.</returns>
        /// <param name="s">S.</param>
        internal static string EscapeStringForASCII(string s)
        {
            string outString = "";
            char[] cArray    = s.ToCharArray();

            foreach(char c in cArray)
                if(c > 127)
                {
                    //non-ASCII Unicode
                    outString += "\\U";
                    string hex = $"{c:x}";

                    while(hex.Length < 4)
                        hex = "0" + hex;

                    outString += hex;
                }
                else
                    outString += c switch
                    {
                        '\\' => "\\\\",
                        '\"' => "\\\"",
                        '\b' => "\\b",
                        '\n' => "\\n",
                        '\r' => "\\r",
                        '\t' => "\\t",
                        _    => c
                    };

            return outString;
        }

        /// <summary>
        ///     Determines whether the specified <see cref="Squirrel.PropertyList.NSObject" /> is equal to the current
        ///     <see cref="Squirrel.PropertyList.NSString" />.
        /// </summary>
        /// <param name="obj">
        ///     The <see cref="Squirrel.PropertyList.NSObject" /> to compare with the current
        ///     <see cref="Squirrel.PropertyList.NSString" />.
        /// </param>
        /// <returns>
        ///     <c>true</c> if the specified <see cref="Squirrel.PropertyList.NSObject" /> is equal to the current
        ///     <see cref="Squirrel.PropertyList.NSString" />; otherwise, <c>false</c>.
        /// </returns>
        public override bool Equals(NSObject obj)
        {
            if(obj is not NSString nsString)
                return false;

            return Content == nsString.Content;
        }

        internal static bool IsASCIIEncodable(string text)
        {
            foreach(char c in text)
                if(c > 0x7F)
                    return false;

            return true;
        }

        public static explicit operator string(NSString value) => value.Content;

        public static explicit operator NSString(string value) => new(value);
    }
}

// PropertyListException.cs
namespace Squirrel.Packaging.OSX
{
    /// <summary>The exception that is thrown when an property list file could not be processed correctly.</summary>
    [Serializable]
    internal class PropertyListException : Exception
    {
        /// <summary>Initializes a new instance of the <see cref="PropertyListException" /> class.</summary>
        public PropertyListException() {}

        /// <summary>Initializes a new instance of the <see cref="PropertyListException" /> class.</summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        public PropertyListException(string message) : base(message) {}

        /// <summary>Initializes a new instance of the <see cref="PropertyListException" /> class.</summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="inner">
        ///     The exception that is the cause of the current exception, or <see langword="null" /> if no inner
        ///     exception is specified.
        /// </param>
        public PropertyListException(string message, Exception inner) : base(message, inner) {}

        protected PropertyListException(SerializationInfo info, StreamingContext context) : base(info, context) {}
    }
}

// PropertyListFormatException.cs// plist-cil - An open source library to parse and generate property lists for .NET
// Copyright (C) 2015 Natalia Portillo
//
// This code is based on:
// plist - An open source library to parse and generate property lists
// Copyright (C) 2014 Daniel Dreibrodt
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

namespace Squirrel.Packaging.OSX
{
    /// <summary>
    ///     A PropertyListFormatException is thrown by the various property list format parsers when an error in the
    ///     format of the given property list is encountered.
    /// </summary>
    /// @author Daniel Dreibrodt
    /// @author Natalia Portillo
    internal class PropertyListFormatException : PropertyListException
    {
        /// <summary>Creates a new exception with the given message.</summary>
        /// <param name="message">A message containing information about the nature of the exception.</param>
        public PropertyListFormatException(string message) : base(message) {}
    }
}

// PropertyListParser.cs
namespace Squirrel.Packaging.OSX
{
    /// <summary>
    ///     This class provides methods to parse property lists. It can handle files, input streams and byte arrays. All
    ///     known property list formats are supported. This class also provides methods to save and convert property lists.
    /// </summary>
    /// @author Daniel Dreibrodt
    /// @author Natalia Portillo
    internal static class PropertyListParser
    {
        const int TYPE_XML           = 0;
        const int TYPE_BINARY        = 1;
        const int TYPE_ASCII         = 2;
        const int TYPE_ERROR_BLANK   = 10;
        const int TYPE_ERROR_UNKNOWN = 11;

        /// <summary>Determines the type of a property list by means of the first bytes of its data</summary>
        /// <returns>The type of the property list</returns>
        /// <param name="dataBeginning">The very first bytes of data of the property list (minus any whitespace) as a string</param>
        static int DetermineTypeExact(ReadOnlySpan<byte> dataBeginning)
        {
            if(dataBeginning.Length == 0)
                return TYPE_ERROR_BLANK;

            if(dataBeginning[0] == '(' ||
               dataBeginning[0] == '{' ||
               dataBeginning[0] == '/')
                return TYPE_ASCII;

            if(dataBeginning[0] == '<')
                return TYPE_XML;

            if(dataBeginning.Length >= 6   &&
               dataBeginning[0]     == 'b' &&
               dataBeginning[1]     == 'p' &&
               dataBeginning[2]     == 'l' &&
               dataBeginning[3]     == 'i' &&
               dataBeginning[4]     == 's' &&
               dataBeginning[5]     == 't')
                return TYPE_BINARY;

            return TYPE_ERROR_UNKNOWN;
        }

        /// <summary>Determines the type of a property list by means of the first bytes of its data</summary>
        /// <returns>The very first bytes of data of the property list (minus any whitespace)</returns>
        /// <param name="bytes">The type of the property list</param>
        static int DetermineType(ReadOnlySpan<byte> bytes)
        {
            if(bytes.Length == 0)
                return TYPE_ERROR_BLANK;

            //Skip any possible whitespace at the beginning of the file
            int offset = 0;

            if(bytes.Length      >= 3    &&
               (bytes[0] & 0xFF) == 0xEF &&
               (bytes[1] & 0xFF) == 0xBB &&
               (bytes[2] & 0xFF) == 0xBF)
                offset += 3;

            while(offset < bytes.Length &&
                  (bytes[offset] == ' ' || bytes[offset] == '\t' || bytes[offset] == '\r' || bytes[offset] == '\n' ||
                   bytes[offset] == '\f'))
                offset++;

            ReadOnlySpan<byte> header = bytes.Slice(offset, Math.Min(8, bytes.Length - offset));

            return DetermineTypeExact(header);
        }

        /// <summary>Determines the type of a property list by means of the first bytes of its data</summary>
        /// <returns>The type of the property list</returns>
        /// <param name="fs">
        ///     An input stream pointing to the beginning of the property list data. The stream will be reset to the
        ///     beginning of the property list data after the type has been determined.
        /// </param>
        static int DetermineType(Stream fs, long offset = 0)
        {
            if(fs.Length == 0)
                return TYPE_ERROR_BLANK;

            long index     = offset;
            long readLimit = index + 1024;
            long mark      = readLimit;
            fs.Seek(offset, SeekOrigin.Current);
            int  b;
            bool bom = false;

            //Skip any possible whitespace at the beginning of the file
            do
            {
                if(++index > readLimit)
                {
                    fs.Seek(mark, SeekOrigin.Begin);

                    return DetermineType(fs, readLimit);
                }

                b = fs.ReadByte();

                //Check if we are reading the Unicode byte order mark (BOM) and skip it
                bom = index < 3 && ((index == 0 && b == 0xEF) ||
                                    (bom        && ((index == 1 && b == 0xBB) || (index == 2 && b == 0xBF))));
            } while(b != -1 &&
                    (b is ' ' or '\t' or '\r' or '\n' or '\f' || bom));

            if(b == -1)
                return TYPE_ERROR_BLANK;

            byte[] magicBytes = new byte[8];
            magicBytes[0] = (byte)b;
            int read = fs.Read(magicBytes, 1, 7);

            int type = DetermineTypeExact(magicBytes.AsSpan(0, read));
            fs.Seek(mark, SeekOrigin.Begin);

            return type;
        }

        /// <summary>Reads all bytes from an Stream and stores them in an array, up to a maximum count.</summary>
        /// <param name="fs">The Stream pointing to the data that should be stored in the array.</param>
        internal static byte[] ReadAll(Stream fs)
        {
            using var outputStream = new MemoryStream();

            fs.CopyTo(outputStream);

            return outputStream.ToArray();
        }

        /// <summary>Parses a property list from a file.</summary>
        /// <param name="filePath">Path to the property list file.</param>
        /// <returns>The root object in the property list. This is usually a NSDictionary but can also be a NSArray.</returns>
        public static NSObject Parse(string filePath) => Parse(new FileInfo(filePath));

        /// <summary>Parses a property list from a file.</summary>
        /// <param name="f">The property list file.</param>
        /// <returns>The root object in the property list. This is usually a NSDictionary but can also be a NSArray.</returns>
        public static NSObject Parse(FileInfo f)
        {
            using FileStream fis = f.OpenRead();

            return Parse(fis);
        }

        /// <summary>Parses a property list from a byte array.</summary>
        /// <param name="bytes">The property list data as a byte array.</param>
        /// <returns>The root object in the property list. This is usually a NSDictionary but can also be a NSArray.</returns>
        public static NSObject Parse(byte[] bytes)
        {
            switch(DetermineType(bytes))
            {
                case TYPE_BINARY: return BinaryPropertyListParser.Parse(bytes);
                case TYPE_XML:    return XmlPropertyListParser.Parse(bytes);
                case TYPE_ASCII:  return ASCIIPropertyListParser.Parse(bytes);
                default:
                    throw new
                        PropertyListFormatException("The given data is not a property list of a supported format.");
            }
        }

        /// <summary>Parses a property list from a byte array.</summary>
        /// <param name="bytes">The property list data as a byte array.</param>
        /// <param name="length">The length of the property list.</param>
        /// <param name="offset">The offset at which to start reading the property list.</param>
        /// <returns>The root object in the property list. This is usually a NSDictionary but can also be a NSArray.</returns>
        public static NSObject Parse(byte[] bytes, int offset, int length) => Parse(bytes.AsSpan(offset, length));

        /// <summary>Parses a property list from a byte span.</summary>
        /// <param name="bytes">The property list data as a byte array.</param>
        /// <returns>The root object in the property list. This is usually a NSDictionary but can also be a NSArray.</returns>
        public static NSObject Parse(ReadOnlySpan<byte> bytes)
        {
            switch(DetermineType(bytes))
            {
                case TYPE_BINARY: return BinaryPropertyListParser.Parse(bytes);
                case TYPE_XML:    return XmlPropertyListParser.Parse(bytes.ToArray());
                case TYPE_ASCII:  return ASCIIPropertyListParser.Parse(bytes);
                default:
                    throw new
                        PropertyListFormatException("The given data is not a property list of a supported format.");
            }
        }

        /// <summary>Parses a property list from an Stream.</summary>
        /// <param name="fs">The Stream delivering the property list data.</param>
        /// <returns>The root object of the property list. This is usually a NSDictionary but can also be a NSArray.</returns>
        public static NSObject Parse(Stream fs) => Parse(ReadAll(fs));

        /// <summary>Saves a property list with the given object as root into a XML file.</summary>
        /// <param name="root">The root object.</param>
        /// <param name="outFile">The output file.</param>
        /// <exception cref="IOException">When an error occurs during the writing process.</exception>
        public static void SaveAsXml(NSObject root, FileInfo outFile)
        {
            string parent = outFile.DirectoryName;

            if(!Directory.Exists(parent))
                Directory.CreateDirectory(parent);

            // Use Create here -- to make sure that when the updated file is shorter than
            // the original file, no "obsolete" data is left at the end.
            using Stream fous = outFile.Open(FileMode.Create, FileAccess.ReadWrite);

            SaveAsXml(root, fous);
        }

        /// <summary>Saves a property list with the given object as root in XML format into an output stream.</summary>
        /// <param name="root">The root object.</param>
        /// <param name="outStream">The output stream.</param>
        /// <exception cref="IOException">When an error occurs during the writing process.</exception>
        public static void SaveAsXml(NSObject root, Stream outStream)
        {
            using var w = new StreamWriter(outStream, Encoding.UTF8, 1024, true);

            w.Write(root.ToXmlPropertyList());
        }

        /// <summary>Converts a given property list file into the OS X and iOS XML format.</summary>
        /// <param name="inFile">The source file.</param>
        /// <param name="outFile">The target file.</param>
        public static void ConvertToXml(FileInfo inFile, FileInfo outFile)
        {
            NSObject root = Parse(inFile);
            SaveAsXml(root, outFile);
        }

        /// <summary>Saves a property list with the given object as root into a binary file.</summary>
        /// <param name="root">The root object.</param>
        /// <param name="outFile">The output file.</param>
        /// <exception cref="IOException">When an error occurs during the writing process.</exception>
        public static void SaveAsBinary(NSObject root, FileInfo outFile)
        {
            string parent = outFile.DirectoryName;

            if(!Directory.Exists(parent))
                Directory.CreateDirectory(parent);

            BinaryPropertyListWriter.Write(outFile, root);
        }

        /// <summary>Saves a property list with the given object as root in binary format into an output stream.</summary>
        /// <param name="root">The root object.</param>
        /// <param name="outStream">The output stream.</param>
        /// <exception cref="IOException">When an error occurs during the writing process.</exception>
        public static void SaveAsBinary(NSObject root, Stream outStream) =>
            BinaryPropertyListWriter.Write(outStream, root);

        /// <summary>Converts a given property list file into the OS X and iOS binary format.</summary>
        /// <param name="inFile">The source file.</param>
        /// <param name="outFile">The target file.</param>
        public static void ConvertToBinary(FileInfo inFile, FileInfo outFile)
        {
            NSObject root = Parse(inFile);
            SaveAsBinary(root, outFile);
        }

        /// <summary>Saves a property list with the given object as root into a ASCII file.</summary>
        /// <param name="root">The root object.</param>
        /// <param name="outFile">The output file.</param>
        /// <exception cref="IOException">When an error occurs during the writing process.</exception>
        public static void SaveAsASCII(NSDictionary root, FileInfo outFile)
        {
            string parent = outFile.DirectoryName;

            if(!Directory.Exists(parent))
                Directory.CreateDirectory(parent);

            using Stream fous = outFile.Open(FileMode.OpenOrCreate, FileAccess.ReadWrite);

            using var w = new StreamWriter(fous, Encoding.ASCII);

            w.Write(root.ToASCIIPropertyList());
        }

        /// <summary>Saves a property list with the given object as root into a ASCII file.</summary>
        /// <param name="root">The root object.</param>
        /// <param name="outFile">The output file.</param>
        /// <exception cref="IOException">When an error occurs during the writing process.</exception>
        public static void SaveAsASCII(NSArray root, FileInfo outFile)
        {
            string parent = outFile.DirectoryName;

            if(!Directory.Exists(parent))
                Directory.CreateDirectory(parent);

            using Stream fous = outFile.Open(FileMode.OpenOrCreate, FileAccess.ReadWrite);

            using var w = new StreamWriter(fous, Encoding.ASCII);

            w.Write(root.ToASCIIPropertyList());
        }

        /// <summary>Converts a given property list file into ASCII format.</summary>
        /// <param name="inFile">The source file.</param>
        /// <param name="outFile">The target file.</param>
        public static void ConvertToASCII(FileInfo inFile, FileInfo outFile)
        {
            NSObject root = Parse(inFile);

            if(root is NSDictionary dictionary)
                SaveAsASCII(dictionary, outFile);
            else if(root is NSArray array)
                SaveAsASCII(array, outFile);
            else
                throw new PropertyListFormatException("The root of the given input property list " +
                                                      "is neither a Dictionary nor an Array!");
        }

        /// <summary>Saves a property list with the given object as root into a GnuStep ASCII file.</summary>
        /// <param name="root">The root object.</param>
        /// <param name="outFile">The output file.</param>
        /// <exception cref="IOException">When an error occurs during the writing process.</exception>
        public static void SaveAsGnuStepASCII(NSDictionary root, FileInfo outFile)
        {
            string parent = outFile.DirectoryName;

            if(!Directory.Exists(parent))
                Directory.CreateDirectory(parent);

            using Stream fous = outFile.Open(FileMode.OpenOrCreate, FileAccess.ReadWrite);

            using var w = new StreamWriter(fous, Encoding.ASCII);

            w.Write(root.ToGnuStepASCIIPropertyList());
        }

        /// <summary>Saves a property list with the given object as root into a GnuStep ASCII file.</summary>
        /// <param name="root">The root object.</param>
        /// <param name="outFile">The output file.</param>
        /// <exception cref="IOException">When an error occurs during the writing process.</exception>
        public static void SaveAsGnuStepASCII(NSArray root, FileInfo outFile)
        {
            string parent = outFile.DirectoryName;

            if(!Directory.Exists(parent))
                Directory.CreateDirectory(parent);

            using Stream fous = outFile.Open(FileMode.OpenOrCreate, FileAccess.ReadWrite);

            using var w = new StreamWriter(fous, Encoding.ASCII);

            w.Write(root.ToGnuStepASCIIPropertyList());
        }

        /// <summary>Converts a given property list file into GnuStep ASCII format.</summary>
        /// <param name="inFile">The source file.</param>
        /// <param name="outFile">The target file.</param>
        public static void ConvertToGnuStepASCII(FileInfo inFile, FileInfo outFile)
        {
            NSObject root = Parse(inFile);

            switch(root)
            {
                case NSDictionary dictionary:
                    SaveAsGnuStepASCII(dictionary, outFile);

                    break;
                case NSArray array:
                    SaveAsGnuStepASCII(array, outFile);

                    break;
                default:
                    throw new PropertyListFormatException("The root of the given input property list " +
                                                          "is neither a Dictionary nor an Array!");
            }
        }
    }
}

// UID.cs
namespace Squirrel.Packaging.OSX
{
    /// <summary>An UID. Only found in binary property lists that are keyed archives.</summary>
    /// @author Daniel Dreibrodt
    /// @author Natalia Portillo
    internal class UID : NSObject
    {
        readonly ulong value;

        /// <summary>Initializes a new instance of the <see cref="Squirrel.PropertyList.UID" /> class.</summary>
        /// <param name="bytes">Bytes.</param>
        public UID(ReadOnlySpan<byte> bytes)
        {
            if(bytes.Length != 1 &&
               bytes.Length != 2 &&
               bytes.Length != 4 &&
               bytes.Length != 8)
                throw new ArgumentException("Type argument is not valid.");

            value = (ulong)BinaryPropertyListParser.ParseLong(bytes);
        }

        /// <summary>
        ///     Initializes a new instance of the <see cref="Squirrel.PropertyList.UID" /> class using an unsigned 8-bit
        ///     number.
        /// </summary>
        /// <param name="number">Unsigned 8-bit number.</param>
        public UID(byte number) => value = number;

        /// <summary>
        ///     Initializes a new instance of the <see cref="Squirrel.PropertyList.UID" /> class using an unsigned 16-bit
        ///     number.
        /// </summary>
        /// <param name="number">Unsigned 16-bit number.</param>
        public UID(ushort number) => value = number;

        /// <summary>
        ///     Initializes a new instance of the <see cref="Squirrel.PropertyList.UID" /> class using an unsigned 32-bit
        ///     number.
        /// </summary>
        /// <param name="number">Unsigned 32-bit number.</param>
        public UID(uint number) => value = number;

        /// <summary>
        ///     Initializes a new instance of the <see cref="Squirrel.PropertyList.UID" /> class using an unsigned 64-bit
        ///     number.
        /// </summary>
        /// <param name="number">Unsigned 64-bit number.</param>
        public UID(ulong number) => value = number;

        /// <summary>Gets the bytes.</summary>
        /// <value>The bytes.</value>
        public byte[] Bytes
        {
            get
            {
                byte[] bytes = new byte[ByteCount];
                GetBytes(bytes);

                return bytes;
            }
        }

        /// <summary>Gets the number of bytes required to represent this <see cref="UID" />.</summary>
        public int ByteCount => value switch
        {
            <= byte.MaxValue   => 1,
            <= ushort.MaxValue => 2,
            <= uint.MaxValue   => 4,
            _                  => 8
        };

        /// <summary>Writes the bytes required to represent this <see cref="UID" /> to a byte span.</summary>
        /// <param name="bytes">The byte span to which to write the byte representation of this UID.</param>
        public void GetBytes(Span<byte> bytes)
        {
            switch(ByteCount)
            {
                case 1:
                    bytes[0] = (byte)value;

                    break;

                case 2:
                    BinaryPrimitives.WriteUInt16BigEndian(bytes, (ushort)value);

                    break;

                case 4:
                    BinaryPrimitives.WriteUInt32BigEndian(bytes, (uint)value);

                    break;

                case 8:
                    BinaryPrimitives.WriteUInt64BigEndian(bytes, value);

                    break;

                default: throw new InvalidOperationException();
            }
        }

        /// <summary>
        ///     UIDs are represented as dictionaries in XML property lists, where the key is always <c>CF$UID</c> and the
        ///     value is the integer representation of the UID.
        /// </summary>
        /// <param name="xml">The xml StringBuilder</param>
        /// <param name="level">The indentation level</param>
        internal override void ToXml(StringBuilder xml, int level)
        {
            Indent(xml, level);
            xml.Append("<dict>");
            xml.AppendLine();

            Indent(xml, level + 1);
            xml.Append("<key>CF$UID</key>");
            xml.AppendLine();

            Indent(xml, level + 1);
            xml.Append($"<integer>{value}</integer>");
            xml.AppendLine();

            Indent(xml, level);
            xml.Append("</dict>");
        }

        internal override void ToBinary(BinaryPropertyListWriter outPlist)
        {
            outPlist.Write(0x80 + ByteCount - 1);
            Span<byte> bytes = stackalloc byte[ByteCount];
            GetBytes(bytes);
            outPlist.Write(bytes);
        }

        internal override void ToASCII(StringBuilder ascii, int level)
        {
            Indent(ascii, level);
            ascii.Append("\"");
            Span<byte> bytes = stackalloc byte[ByteCount];
            GetBytes(bytes);

            foreach(byte b in bytes)
                ascii.Append($"{b:x2}");

            ascii.Append("\"");
        }

        internal override void ToASCIIGnuStep(StringBuilder ascii, int level) => ToASCII(ascii, level);

        /// <summary>
        ///     Determines whether the specified <see cref="Squirrel.PropertyList.NSObject" /> is equal to the current
        ///     <see cref="Squirrel.PropertyList.UID" />.
        /// </summary>
        /// <param name="obj">
        ///     The <see cref="Squirrel.PropertyList.NSObject" /> to compare with the current
        ///     <see cref="Squirrel.PropertyList.UID" />.
        /// </param>
        /// <returns>
        ///     <c>true</c> if the specified <see cref="Squirrel.PropertyList.NSObject" /> is equal to the current
        ///     <see cref="Squirrel.PropertyList.UID" />; otherwise, <c>false</c>.
        /// </returns>
        public override bool Equals(NSObject obj) => Equals((object)obj);

        /// <inheritdoc />
        public override bool Equals(object obj)
        {
            if(obj is not UID uid)
                return false;

            return uid.value == value;
        }

        /// <inheritdoc />
        public override int GetHashCode() => value.GetHashCode();

        /// <inheritdoc />
        public override string ToString() => $"{value} (UID)";

        /// <summary>Gets a <see cref="ulong" /> which represents this <see cref="UID" />.</summary>
        /// <returns>A <see cref="ulong" /> which represents this <see cref="UID" />.</returns>
        public ulong ToUInt64() => value;
    }
}

// XmlPropertyListParser.cs
namespace Squirrel.Packaging.OSX
{
    /// <summary>Parses XML property lists.</summary>
    /// @author Daniel Dreibrodt
    /// @author Natalia Portillo
    internal static class XmlPropertyListParser
    {
        /// <summary>Parses a XML property list file.</summary>
        /// <param name="f">The XML property list file.</param>
        /// <returns>The root object of the property list. This is usually a NSDictionary but can also be a NSArray.</returns>
        public static NSObject Parse(FileInfo f)
        {
            var doc = new XmlDocument();

            var settings = new XmlReaderSettings
            {
                DtdProcessing = DtdProcessing.Ignore
            };

            using(Stream stream = f.OpenRead())
                using(var reader = XmlReader.Create(stream, settings))
                    doc.Load(reader);

            return ParseDocument(doc);
        }

        /// <summary>Parses a XML property list from a byte array.</summary>
        /// <param name="bytes">The byte array containing the property list's data.</param>
        /// <returns>The root object of the property list. This is usually a NSDictionary but can also be a NSArray.</returns>
        public static NSObject Parse(byte[] bytes)
        {
            var bis = new MemoryStream(bytes);

            return Parse(bis);
        }

        /// <summary>Parses a XML property list from an input stream.</summary>
        /// <param name="str">The input stream pointing to the property list's data.</param>
        /// <returns>The root object of the property list. This is usually a NSDictionary but can also be a NSArray.</returns>
        public static NSObject Parse(Stream str)
        {
            var doc = new XmlDocument();

            var settings = new XmlReaderSettings();
            settings.DtdProcessing = DtdProcessing.Ignore;

            using(var reader = XmlReader.Create(str, settings))
                doc.Load(reader);

            return ParseDocument(doc);
        }

        /// <summary>Parses a XML property list from a string.</summary>
        /// <param name="value">The string pointing to the property list's data.</param>
        /// <returns>The root object of the property list. This is usually a NSDictionary but can also be a NSArray.</returns>
        public static NSObject ParseString(string value)
        {
            var doc = new XmlDocument();

            var settings = new XmlReaderSettings();
            settings.DtdProcessing = DtdProcessing.Ignore;

            doc.LoadXml(value);

            return ParseDocument(doc);
        }

        /// <summary>Parses the XML document by generating the appropriate NSObjects for each XML node.</summary>
        /// <returns>The root NSObject of the property list contained in the XML document.</returns>
        /// <param name="doc">The XML document.</param>
        static NSObject ParseDocument(XmlDocument doc)
        {
            XmlNode docType = doc.ChildNodes.OfType<XmlNode>().
                                  SingleOrDefault(n => n.NodeType == XmlNodeType.DocumentType);

            if(docType == null)
            {
                if(doc.DocumentElement != null &&
                   !doc.DocumentElement.Name.Equals("plist"))
                    throw new XmlException("The given XML document is not a property list.");
            }
            else if(!docType.Name.Equals("plist"))
                throw new XmlException("The given XML document is not a property list.");

            XmlNode rootNode;

            if(doc.DocumentElement is { Name: "plist" })
            {
                //Root element wrapped in plist tag
                List<XmlNode> rootNodes = FilterElementNodes(doc.DocumentElement.ChildNodes);

                rootNode = rootNodes.Count switch
                {
                    0 => throw new PropertyListFormatException("The given XML property list has no root element!"),
                    1 => rootNodes[0],
                    _ => throw new
                             PropertyListFormatException("The given XML property list has more than one root element!")
                };
            }
            else

                //Root NSObject not wrapped in plist-tag
                rootNode = doc.DocumentElement;

            return ParseObject(rootNode);
        }

        /// <summary>Parses a node in the XML structure and returns the corresponding NSObject</summary>
        /// <returns>The corresponding NSObject.</returns>
        /// <param name="n">The XML node.</param>
        static NSObject ParseObject(XmlNode n)
        {
            switch(n.Name)
            {
                // Special case for UID values
                case "dict" when n.ChildNodes.Count        == 2        && n.ChildNodes[0].Name == "key"     &&
                                 n.ChildNodes[0].InnerText == "CF$UID" && n.ChildNodes[1].Name == "integer" &&
                                 uint.TryParse(n.ChildNodes[1].InnerText, out uint uidValue): return new UID(uidValue);
                case "dict":
                {
                    var           dict     = new NSDictionary();
                    List<XmlNode> children = FilterElementNodes(n.ChildNodes);

                    for(int i = 0; i < children.Count; i += 2)
                    {
                        XmlNode key = children[i];
                        XmlNode val = children[i + 1];

                        string keyString = GetNodeTextContents(key);

                        dict.Add(keyString, ParseObject(val));
                    }

                    return dict;
                }
                case "array":
                {
                    List<XmlNode> children = FilterElementNodes(n.ChildNodes);
                    var           array    = new NSArray(children.Count);

                    for(int i = 0; i < children.Count; i++)
                        array.Add(ParseObject(children[i]));

                    return array;
                }
                case "true":    return new NSNumber(true);
                case "false":   return new NSNumber(false);
                case "integer": return new NSNumber(GetNodeTextContents(n), NSNumber.INTEGER);
                case "real":    return new NSNumber(GetNodeTextContents(n), NSNumber.REAL);
                case "string":  return new NSString(GetNodeTextContents(n));
                case "data":    return new NSData(GetNodeTextContents(n));
                default:        return n.Name.Equals("date") ? new NSDate(GetNodeTextContents(n)) : null;
            }
        }

        /// <summary>Returns all element nodes that are contained in a list of nodes.</summary>
        /// <returns>The sublist containing only nodes representing actual elements.</returns>
        /// <param name="list">The list of nodes to search.</param>
        static List<XmlNode> FilterElementNodes(XmlNodeList list)
        {
            List<XmlNode> result = new();

            foreach(XmlNode child in list)
                if(child.NodeType == XmlNodeType.Element)
                    result.Add(child);

            return result;
        }

        /// <summary>
        ///     Returns a node's text content. This method will return the text value represented by the node's direct
        ///     children. If the given node is a TEXT or CDATA node, then its value is returned.
        /// </summary>
        /// <returns>The node's text content.</returns>
        /// <param name="n">The node.</param>
        static string GetNodeTextContents(XmlNode n)
        {
            if(n.NodeType is XmlNodeType.Text or XmlNodeType.CDATA)
            {
                string content = n.Value; //This concatenates any adjacent text/cdata/entity nodes

                return content ?? "";
            }

            if(!n.HasChildNodes)
                return "";

            XmlNodeList children = n.ChildNodes;

            foreach(XmlNode child in children)

                //Skip any non-text nodes, like comments or entities
                if(child.NodeType is XmlNodeType.Text or XmlNodeType.CDATA)
                {
                    string content = child.Value; //This concatenates any adjacent text/cdata/entity nodes

                    return content ?? "";
                }

            return "";
        }
    }
}
